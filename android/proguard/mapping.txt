com.badlogic.gdx.Application -> com.badlogic.gdx.a:
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Graphics getGraphics() -> b
    void log(java.lang.String,java.lang.String) -> a
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void debug(java.lang.String,java.lang.String) -> c
    com.badlogic.gdx.Application$ApplicationType getType() -> c
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    void postRunnable(java.lang.Runnable) -> a
com.badlogic.gdx.Application$ApplicationType -> com.badlogic.gdx.b:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> c
    com.badlogic.gdx.Application$ApplicationType Applet -> d
    com.badlogic.gdx.Application$ApplicationType WebGL -> e
    com.badlogic.gdx.Application$ApplicationType iOS -> f
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> g
    com.badlogic.gdx.Application$ApplicationType[] values() -> values
    com.badlogic.gdx.Application$ApplicationType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.ApplicationListener -> com.badlogic.gdx.c:
    void create() -> a
    void resize(int,int) -> a
    void render() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.Audio -> com.badlogic.gdx.d:
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.Files -> com.badlogic.gdx.e:
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getExternalStoragePath() -> a
    java.lang.String getLocalStoragePath() -> b
com.badlogic.gdx.Files$FileType -> com.badlogic.gdx.f:
    com.badlogic.gdx.Files$FileType Classpath -> a
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType[] values() -> values
    com.badlogic.gdx.Files$FileType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Game -> com.badlogic.gdx.g:
    com.badlogic.gdx.Screen screen -> a
    void dispose() -> e
    void pause() -> c
    void resume() -> d
    void render() -> b
    void resize(int,int) -> a
    void setScreen(com.badlogic.gdx.Screen) -> a
    com.badlogic.gdx.Screen getScreen() -> f
com.badlogic.gdx.Gdx -> com.badlogic.gdx.h:
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL30 gl30 -> i
com.badlogic.gdx.Graphics -> com.badlogic.gdx.i:
    int getWidth() -> a
    int getHeight() -> b
    float getDeltaTime() -> c
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> d
    boolean supportsExtension(java.lang.String) -> a
    boolean isContinuousRendering() -> e
    void requestRendering() -> f
com.badlogic.gdx.Graphics$BufferFormat -> com.badlogic.gdx.j:
    int r -> a
    int g -> b
    int b -> c
    int a -> d
    int depth -> e
    int stencil -> f
    int samples -> g
    boolean coverageSampling -> h
    java.lang.String toString() -> toString
com.badlogic.gdx.Graphics$DisplayMode -> com.badlogic.gdx.k:
    int width -> a
    int height -> b
    int refreshRate -> c
    int bitsPerPixel -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.Input -> com.badlogic.gdx.l:
    float getAccelerometerX() -> a
    float getAccelerometerY() -> b
    int getX() -> c
    int getY() -> d
    boolean isButtonPressed(int) -> a
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
com.badlogic.gdx.Input$Orientation -> com.badlogic.gdx.m:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation Portrait -> b
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation[] values() -> values
    com.badlogic.gdx.Input$Orientation valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.Input$TextInputListener -> com.badlogic.gdx.n:
com.badlogic.gdx.InputAdapter -> com.badlogic.gdx.o:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
com.badlogic.gdx.InputProcessor -> com.badlogic.gdx.p:
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean touchDragged(int,int,int) -> a
com.badlogic.gdx.LifecycleListener -> com.badlogic.gdx.q:
    void pause() -> a
    void resume() -> b
    void dispose() -> c
com.badlogic.gdx.Net -> com.badlogic.gdx.r:
com.badlogic.gdx.Preferences -> com.badlogic.gdx.s:
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> a
    java.lang.String getString(java.lang.String,java.lang.String) -> b
    void clear() -> a
    void flush() -> b
com.badlogic.gdx.Screen -> com.badlogic.gdx.t:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void hide() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.ScreenAdapter -> com.badlogic.gdx.u:
    void render(float) -> a
    void resize(int,int) -> a
    void show() -> a
    void hide() -> b
    void pause() -> c
    void resume() -> d
    void dispose() -> e
com.badlogic.gdx.ai.fsm.DefaultStateMachine -> com.badlogic.gdx.a.a.a:
    java.lang.Object owner -> a
    com.badlogic.gdx.ai.fsm.State currentState -> b
    com.badlogic.gdx.ai.fsm.State previousState -> c
    com.badlogic.gdx.ai.fsm.State globalState -> d
    void setInitialState(com.badlogic.gdx.ai.fsm.State) -> a
    void setGlobalState(com.badlogic.gdx.ai.fsm.State) -> b
    com.badlogic.gdx.ai.fsm.State getCurrentState() -> a
    void changeState(com.badlogic.gdx.ai.fsm.State) -> c
    void revertToPreviousState() -> b
com.badlogic.gdx.ai.fsm.State -> com.badlogic.gdx.a.a.b:
    void enter(java.lang.Object) -> a
    void exit(java.lang.Object) -> b
com.badlogic.gdx.ai.fsm.StateMachine -> com.badlogic.gdx.a.a.c:
    void changeState(com.badlogic.gdx.ai.fsm.State) -> c
    void revertToPreviousState() -> b
    com.badlogic.gdx.ai.fsm.State getCurrentState() -> a
com.badlogic.gdx.assets.AssetDescriptor -> com.badlogic.gdx.b.a:
    java.lang.String fileName -> a
    java.lang.Class type -> b
    com.badlogic.gdx.assets.AssetLoaderParameters params -> c
    com.badlogic.gdx.files.FileHandle file -> d
    java.lang.String toString() -> toString
com.badlogic.gdx.assets.AssetErrorListener -> com.badlogic.gdx.b.b:
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.badlogic.gdx.assets.AssetLoaderParameters -> com.badlogic.gdx.b.c:
    com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback loadedCallback -> a
com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback -> com.badlogic.gdx.b.d:
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.assets.AssetLoadingTask -> com.badlogic.gdx.b.e:
    com.badlogic.gdx.assets.AssetManager manager -> a
    com.badlogic.gdx.assets.AssetDescriptor assetDesc -> b
    com.badlogic.gdx.assets.loaders.AssetLoader loader -> c
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> d
    long startTime -> e
    boolean asyncDone -> f
    boolean dependenciesLoaded -> g
    com.badlogic.gdx.utils.Array dependencies -> h
    com.badlogic.gdx.utils.async.AsyncResult depsFuture -> i
    com.badlogic.gdx.utils.async.AsyncResult loadFuture -> j
    java.lang.Object asset -> k
    int ticks -> l
    boolean cancel -> m
    java.lang.Void call() -> a
    boolean update() -> b
    void handleSyncLoader() -> e
    void handleAsyncLoader() -> f
    com.badlogic.gdx.files.FileHandle resolve(com.badlogic.gdx.assets.loaders.AssetLoader,com.badlogic.gdx.assets.AssetDescriptor) -> a
    java.lang.Object getAsset() -> c
    java.lang.Object call() -> d
com.badlogic.gdx.assets.AssetManager -> com.badlogic.gdx.b.f:
    com.badlogic.gdx.utils.ObjectMap assets -> a
    com.badlogic.gdx.utils.ObjectMap assetTypes -> b
    com.badlogic.gdx.utils.ObjectMap assetDependencies -> c
    com.badlogic.gdx.utils.ObjectSet injected -> d
    com.badlogic.gdx.utils.ObjectMap loaders -> e
    com.badlogic.gdx.utils.Array loadQueue -> f
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> g
    java.util.Stack tasks -> h
    com.badlogic.gdx.assets.AssetErrorListener listener -> i
    int loaded -> j
    int toLoad -> k
    com.badlogic.gdx.utils.Logger log -> l
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    void unload(java.lang.String) -> b
    java.lang.String getAssetFileName(java.lang.Object) -> a
    boolean isLoaded(java.lang.String) -> c
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class,java.lang.String) -> a
    void load(java.lang.String,java.lang.Class) -> b
    void load(java.lang.String,java.lang.Class,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    boolean update() -> a
    void finishLoading() -> b
    void injectDependencies(java.lang.String,com.badlogic.gdx.utils.Array) -> a
    void injectDependency(java.lang.String,com.badlogic.gdx.assets.AssetDescriptor) -> a
    void nextTask() -> e
    void addTask(com.badlogic.gdx.assets.AssetDescriptor) -> a
    void addAsset(java.lang.String,java.lang.Class,java.lang.Object) -> a
    boolean updateTask() -> f
    void incrementRefCountedDependencies(java.lang.String) -> f
    void handleTaskError(java.lang.Throwable) -> a
    void setLoader(java.lang.Class,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void setLoader(java.lang.Class,java.lang.String,com.badlogic.gdx.assets.loaders.AssetLoader) -> a
    void dispose() -> c
    void clear() -> d
    int getReferenceCount(java.lang.String) -> d
    void setReferenceCount(java.lang.String,int) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String) -> e
com.badlogic.gdx.assets.RefCountedContainer -> com.badlogic.gdx.b.g:
    java.lang.Object object -> a
    int refCount -> b
    void incRefCount() -> a
    void decRefCount() -> b
    int getRefCount() -> c
    void setRefCount(int) -> a
    java.lang.Object getObject(java.lang.Class) -> a
com.badlogic.gdx.assets.loaders.AssetLoader -> com.badlogic.gdx.b.a.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> com.badlogic.gdx.b.a.b:
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
com.badlogic.gdx.assets.loaders.BitmapFontLoader -> com.badlogic.gdx.b.a.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter -> com.badlogic.gdx.b.a.d:
    boolean flip -> b
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData bitmapFontData -> f
com.badlogic.gdx.assets.loaders.FileHandleResolver -> com.badlogic.gdx.b.a.e:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader -> com.badlogic.gdx.b.a.f:
    com.badlogic.gdx.utils.I18NBundle bundle -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    com.badlogic.gdx.utils.I18NBundle loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter -> com.badlogic.gdx.b.a.g:
    java.util.Locale locale -> b
    java.lang.String encoding -> c
com.badlogic.gdx.assets.loaders.ModelLoader -> com.badlogic.gdx.b.a.h:
    com.badlogic.gdx.utils.Array items -> a
    com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters defaultParameters -> b
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.Model loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters -> com.badlogic.gdx.b.a.i:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter textureParameter -> b
com.badlogic.gdx.assets.loaders.MusicLoader -> com.badlogic.gdx.b.a.j:
    com.badlogic.gdx.audio.Music music -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    com.badlogic.gdx.audio.Music loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter -> com.badlogic.gdx.b.a.k:
com.badlogic.gdx.assets.loaders.ParticleEffectLoader -> com.badlogic.gdx.b.a.l:
    com.badlogic.gdx.graphics.g2d.ParticleEffect load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter -> com.badlogic.gdx.b.a.m:
    java.lang.String atlasFile -> b
    java.lang.String atlasPrefix -> c
    com.badlogic.gdx.files.FileHandle imagesDir -> d
com.badlogic.gdx.assets.loaders.PixmapLoader -> com.badlogic.gdx.b.a.n:
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    com.badlogic.gdx.graphics.Pixmap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter -> com.badlogic.gdx.b.a.o:
com.badlogic.gdx.assets.loaders.SkinLoader -> com.badlogic.gdx.b.a.p:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> b
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter -> com.badlogic.gdx.b.a.q:
    java.lang.String textureAtlasPath -> b
    com.badlogic.gdx.utils.ObjectMap resources -> c
com.badlogic.gdx.assets.loaders.SoundLoader -> com.badlogic.gdx.b.a.r:
    com.badlogic.gdx.audio.Sound sound -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    com.badlogic.gdx.audio.Sound loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter -> com.badlogic.gdx.b.a.s:
com.badlogic.gdx.assets.loaders.SynchronousAssetLoader -> com.badlogic.gdx.b.a.t:
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader -> com.badlogic.gdx.b.a.u:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData data -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter -> com.badlogic.gdx.b.a.v:
    boolean flip -> b
com.badlogic.gdx.assets.loaders.TextureLoader -> com.badlogic.gdx.b.a.w:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo info -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    com.badlogic.gdx.graphics.Texture loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> a
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> b
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo -> com.badlogic.gdx.b.a.x:
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.TextureData data -> b
    com.badlogic.gdx.graphics.Texture texture -> c
com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter -> com.badlogic.gdx.b.a.y:
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.graphics.TextureData textureData -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> i
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> com.badlogic.gdx.b.a.a.a:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.audio.Music -> com.badlogic.gdx.c.a:
    void play() -> a
    void pause() -> b
    void stop() -> d
    void setLooping(boolean) -> a
    void setVolume(float) -> a
com.badlogic.gdx.audio.Music$OnCompletionListener -> com.badlogic.gdx.c.b:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.audio.Sound -> com.badlogic.gdx.c.c:
    long play(float) -> a
    void stop() -> a
com.badlogic.gdx.backends.android.AndroidApplication -> com.badlogic.gdx.backends.android.a:
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    com.badlogic.gdx.ApplicationListener listener -> f
    android.os.Handler handler -> g
    boolean firstResume -> h
    com.badlogic.gdx.utils.Array runnables -> i
    com.badlogic.gdx.utils.Array executedRunnables -> j
    com.badlogic.gdx.utils.Array lifecycleListeners -> k
    int logLevel -> l
    boolean useImmersiveMode -> m
    boolean hideStatusBar -> n
    int wasFocusChanged -> o
    boolean isWaitingForAudio -> p
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> a
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> d
    void createWakeLock(boolean) -> a
    void hideStatusBar(boolean) -> b
    void onWindowFocusChanged(boolean) -> onWindowFocusChanged
    void useImmersiveMode(boolean) -> c
    void onPause() -> onPause
    void onResume() -> onResume
    void onDestroy() -> onDestroy
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> a
    com.badlogic.gdx.Audio getAudio() -> e
    com.badlogic.gdx.Files getFiles() -> f
    com.badlogic.gdx.Graphics getGraphics() -> b
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> g
    com.badlogic.gdx.Net getNet() -> h
    com.badlogic.gdx.Application$ApplicationType getType() -> c
    int getVersion() -> i
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> a
    void postRunnable(java.lang.Runnable) -> a
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void debug(java.lang.String,java.lang.String) -> c
    void log(java.lang.String,java.lang.String) -> a
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void error(java.lang.String,java.lang.String) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> a
    android.content.Context getContext() -> j
    com.badlogic.gdx.utils.Array getRunnables() -> k
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> l
    com.badlogic.gdx.utils.Array getLifecycleListeners() -> m
com.badlogic.gdx.backends.android.AndroidApplication$1 -> com.badlogic.gdx.backends.android.b:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void resume() -> b
    void pause() -> a
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidApplicationBase -> com.badlogic.gdx.backends.android.c:
    android.content.Context getContext() -> j
    com.badlogic.gdx.utils.Array getRunnables() -> k
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> l
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> g
    com.badlogic.gdx.utils.Array getLifecycleListeners() -> m
    android.view.WindowManager getWindowManager() -> getWindowManager
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> com.badlogic.gdx.backends.android.d:
    int r -> a
    int g -> b
    int b -> c
    int a -> d
    int depth -> e
    int stencil -> f
    int numSamples -> g
    boolean useAccelerometer -> h
    boolean useCompass -> i
    int touchSleepTime -> j
    boolean useWakelock -> k
    boolean hideStatusBar -> l
    boolean disableAudio -> m
    int maxSimultaneousSounds -> n
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> o
    boolean getTouchEventsForLiveWallpaper -> p
    boolean useImmersiveMode -> q
    boolean useGLSurfaceView20API18 -> r
com.badlogic.gdx.backends.android.AndroidAudio -> com.badlogic.gdx.backends.android.e:
    android.media.SoundPool soundPool -> b
    android.media.AudioManager manager -> c
    java.util.List musics -> a
    void pause() -> a
    void resume() -> b
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> a
    void dispose() -> c
com.badlogic.gdx.backends.android.AndroidFileHandle -> com.badlogic.gdx.backends.android.f:
    android.content.res.AssetManager assets -> a
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    java.io.InputStream read() -> b
    boolean exists() -> c
    long length() -> d
    java.io.File file() -> e
com.badlogic.gdx.backends.android.AndroidFiles -> com.badlogic.gdx.backends.android.g:
    java.lang.String sdcard -> a
    java.lang.String localpath -> b
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> a
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getExternalStoragePath() -> a
    java.lang.String getLocalStoragePath() -> b
com.badlogic.gdx.backends.android.AndroidGL20 -> com.badlogic.gdx.backends.android.AndroidGL20:
    void init() -> init
    void glAttachShader(int,int) -> glAttachShader
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glCompileShader(int) -> glCompileShader
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthMask(boolean) -> glDepthMask
    void glDisable(int) -> glDisable
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnable(int) -> glEnable
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    java.lang.String glGetString(int) -> glGetString
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glLinkProgram(int) -> glLinkProgram
    void glPixelStorei(int,int) -> glPixelStorei
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glScissor(int,int,int,int) -> glScissor
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glUniform1i(int,int) -> glUniform1i
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
    void glViewport(int,int,int,int) -> glViewport
com.badlogic.gdx.backends.android.AndroidGraphics -> com.badlogic.gdx.backends.android.h:
    android.view.View view -> a
    int width -> b
    int height -> c
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> d
    com.badlogic.gdx.graphics.GL20 gl20 -> e
    javax.microedition.khronos.egl.EGLContext eglContext -> f
    java.lang.String extensions -> g
    long lastFrameTime -> h
    float deltaTime -> i
    long frameStart -> j
    int frames -> k
    int fps -> l
    com.badlogic.gdx.math.WindowedMean mean -> m
    boolean created -> n
    boolean running -> o
    boolean pause -> p
    boolean resume -> q
    boolean destroy -> r
    float ppiX -> v
    float ppiY -> w
    float ppcX -> x
    float ppcY -> y
    float density -> z
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> s
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> A
    boolean isContinuous -> B
    int[] value -> t
    java.lang.Object synch -> u
    void preserveEGLContextOnPause() -> g
    android.view.View createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> a
    void onPauseGLSurfaceView() -> h
    void onResumeGLSurfaceView() -> i
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> j
    void updatePpi() -> r
    boolean checkGL20() -> k
    int getHeight() -> b
    int getWidth() -> a
    void setupGL(javax.microedition.khronos.opengles.GL10) -> a
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> a
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
    void resume() -> l
    void pause() -> m
    void destroy() -> n
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    float getDeltaTime() -> c
    void clearManagedCaches() -> o
    void logManagedCachesStatus() -> p
    android.view.View getView() -> q
    com.badlogic.gdx.Graphics$DisplayMode getDesktopDisplayMode() -> d
    boolean supportsExtension(java.lang.String) -> a
    void setContinuousRendering(boolean) -> a
    boolean isContinuousRendering() -> e
    void requestRendering() -> f
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> com.badlogic.gdx.backends.android.i:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidInput -> com.badlogic.gdx.backends.android.j:
    com.badlogic.gdx.utils.Pool usedKeyEvents -> a
    com.badlogic.gdx.utils.Pool usedTouchEvents -> b
    java.util.ArrayList keyListeners -> c
    java.util.ArrayList keyEvents -> d
    java.util.ArrayList touchEvents -> e
    int[] touchX -> f
    int[] touchY -> g
    int[] deltaX -> h
    int[] deltaY -> i
    boolean[] touched -> j
    int[] realId -> k
    boolean hasMultitouch -> l
    int keyCount -> u
    boolean[] keys -> v
    boolean keyJustPressed -> w
    boolean[] justPressedKeys -> x
    android.hardware.SensorManager manager -> y
    boolean accelerometerAvailable -> m
    float[] accelerometerValues -> z
    java.lang.String text -> A
    com.badlogic.gdx.Input$TextInputListener textListener -> B
    android.os.Handler handle -> C
    com.badlogic.gdx.Application app -> n
    android.content.Context context -> o
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> D
    int sleepTime -> E
    boolean catchBack -> F
    boolean catchMenu -> G
    android.os.Vibrator vibrator -> p
    boolean compassAvailable -> H
    boolean keyboardAvailable -> q
    float[] magneticFieldValues -> I
    float azimuth -> J
    float pitch -> K
    float roll -> L
    float inclination -> M
    boolean justTouched -> N
    com.badlogic.gdx.InputProcessor processor -> O
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> P
    com.badlogic.gdx.Input$Orientation nativeOrientation -> Q
    long currentEventTimeStamp -> R
    com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard onscreenKeyboard -> S
    android.hardware.SensorEventListener accelerometerListener -> T
    android.hardware.SensorEventListener compassListener -> U
    boolean requestFocus -> r
    float[] R -> s
    float[] orientation -> t
    float getAccelerometerX() -> a
    float getAccelerometerY() -> b
    int getX() -> c
    int getY() -> d
    boolean isTouched() -> e
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> a
    void processEvents() -> f
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
    boolean isButtonPressed(int) -> a
    void registerSensorListeners() -> g
    void unregisterSensorListeners() -> h
    int getFreePointerIndex() -> i
    int[] resize(int[]) -> a
    boolean[] resize(boolean[]) -> a
    int lookUpPointerIndex(int) -> b
    int getRotation() -> j
    void onPause() -> k
    void onResume() -> l
com.badlogic.gdx.backends.android.AndroidInput$1 -> com.badlogic.gdx.backends.android.k:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$KeyEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$2 -> com.badlogic.gdx.backends.android.l:
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> a
    com.badlogic.gdx.backends.android.AndroidInput$TouchEvent newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.backends.android.AndroidInput$KeyEvent -> com.badlogic.gdx.backends.android.m:
    long timeStamp -> a
    int type -> b
    int keyCode -> c
    char keyChar -> d
com.badlogic.gdx.backends.android.AndroidInput$SensorListener -> com.badlogic.gdx.backends.android.n:
    float[] accelerometerValues -> a
    float[] magneticFieldValues -> b
    com.badlogic.gdx.Input$Orientation nativeOrientation -> c
    com.badlogic.gdx.backends.android.AndroidInput this$0 -> d
    void onAccuracyChanged(android.hardware.Sensor,int) -> onAccuracyChanged
    void onSensorChanged(android.hardware.SensorEvent) -> onSensorChanged
com.badlogic.gdx.backends.android.AndroidInput$TouchEvent -> com.badlogic.gdx.backends.android.o:
    long timeStamp -> a
    int type -> b
    int x -> c
    int y -> d
    int pointer -> e
com.badlogic.gdx.backends.android.AndroidInputFactory -> com.badlogic.gdx.backends.android.p:
    com.badlogic.gdx.backends.android.AndroidInput newAndroidInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> a
com.badlogic.gdx.backends.android.AndroidInputThreePlus -> com.badlogic.gdx.backends.android.q:
    java.util.ArrayList genericMotionListeners -> u
    boolean onGenericMotion(android.view.View,android.view.MotionEvent) -> onGenericMotion
com.badlogic.gdx.backends.android.AndroidMultiTouchHandler -> com.badlogic.gdx.backends.android.r:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.AndroidInput,int,int,int,int,long) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidMusic -> com.badlogic.gdx.backends.android.s:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    android.media.MediaPlayer player -> d
    boolean isPrepared -> e
    boolean wasPlaying -> a
    float volume -> f
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> b
    void dispose() -> c
    boolean isPlaying() -> e
    void pause() -> b
    void play() -> a
    void setLooping(boolean) -> a
    void setVolume(float) -> a
    void stop() -> d
    void onCompletion(android.media.MediaPlayer) -> onCompletion
com.badlogic.gdx.backends.android.AndroidMusic$1 -> com.badlogic.gdx.backends.android.t:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> a
    void run() -> run
com.badlogic.gdx.backends.android.AndroidNet -> com.badlogic.gdx.backends.android.u:
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard -> com.badlogic.gdx.backends.android.v:
    android.content.Context context -> a
    android.os.Handler handler -> b
    com.badlogic.gdx.backends.android.AndroidInput input -> c
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
    boolean onKey(android.view.View,int,android.view.KeyEvent) -> onKey
com.badlogic.gdx.backends.android.AndroidPreferences -> com.badlogic.gdx.backends.android.w:
    android.content.SharedPreferences sharedPrefs -> a
    android.content.SharedPreferences$Editor editor -> b
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> a
    java.lang.String getString(java.lang.String,java.lang.String) -> b
    void clear() -> a
    void flush() -> b
    void edit() -> c
com.badlogic.gdx.backends.android.AndroidSound -> com.badlogic.gdx.backends.android.x:
    android.media.SoundPool soundPool -> a
    android.media.AudioManager manager -> b
    int soundId -> c
    com.badlogic.gdx.utils.IntArray streamIds -> d
    void dispose() -> c
    long play(float) -> a
    void stop() -> a
com.badlogic.gdx.backends.android.AndroidTouchHandler -> com.badlogic.gdx.backends.android.y:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.AndroidInput) -> a
    boolean supportsMultitouch(android.content.Context) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> com.badlogic.gdx.backends.android.z:
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> com.badlogic.gdx.backends.android.a.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> com.badlogic.gdx.backends.android.a.b:
    java.lang.String TAG -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> b
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> com.badlogic.gdx.backends.android.a.c:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> com.badlogic.gdx.backends.android.a.d:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> com.badlogic.gdx.backends.android.a.e:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> createContext
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> destroyContext
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18 -> com.badlogic.gdx.backends.android.a.f:
    java.lang.String TAG -> a
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> b
    void onMeasure(int,int) -> onMeasure
    android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo) -> onCreateInputConnection
    void init(boolean,int,int) -> a
    void checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$1 -> com.badlogic.gdx.backends.android.a.g:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18 this$0 -> a
    boolean deleteSurroundingText(int,int) -> deleteSurroundingText
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$ConfigChooser -> com.badlogic.gdx.backends.android.a.h:
    int EGL_OPENGL_ES2_BIT -> g
    int[] s_configAttribs2 -> h
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18$ContextFactory -> com.badlogic.gdx.backends.android.a.i:
    int EGL_CONTEXT_CLIENT_VERSION -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 -> com.badlogic.gdx.backends.android.a.j:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager sGLThreadManager -> a
    java.lang.ref.WeakReference mThisWeakRef -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread mGLThread -> c
    android.opengl.GLSurfaceView$Renderer mRenderer -> d
    boolean mDetached -> e
    android.opengl.GLSurfaceView$EGLConfigChooser mEGLConfigChooser -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory mEGLContextFactory -> g
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory mEGLWindowSurfaceFactory -> h
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper mGLWrapper -> i
    int mDebugFlags -> j
    int mEGLContextClientVersion -> k
    boolean mPreserveEGLContextOnPause -> l
    void finalize() -> finalize
    void init() -> e
    void setGLWrapper(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper) -> setGLWrapper
    void setDebugFlags(int) -> setDebugFlags
    int getDebugFlags() -> getDebugFlags
    void setPreserveEGLContextOnPause(boolean) -> setPreserveEGLContextOnPause
    boolean getPreserveEGLContextOnPause() -> getPreserveEGLContextOnPause
    void setRenderer(android.opengl.GLSurfaceView$Renderer) -> setRenderer
    void setEGLContextFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory) -> setEGLContextFactory
    void setEGLWindowSurfaceFactory(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory) -> setEGLWindowSurfaceFactory
    void setEGLConfigChooser(android.opengl.GLSurfaceView$EGLConfigChooser) -> setEGLConfigChooser
    void setEGLConfigChooser(boolean) -> setEGLConfigChooser
    void setEGLConfigChooser(int,int,int,int,int,int) -> a
    void setEGLContextClientVersion(int) -> setEGLContextClientVersion
    void setRenderMode(int) -> setRenderMode
    int getRenderMode() -> getRenderMode
    void requestRender() -> a
    void surfaceCreated(android.view.SurfaceHolder) -> surfaceCreated
    void surfaceDestroyed(android.view.SurfaceHolder) -> surfaceDestroyed
    void surfaceChanged(android.view.SurfaceHolder,int,int,int) -> surfaceChanged
    void onPause() -> b
    void onResume() -> c
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    void checkRenderThreadState() -> f
    int access$200(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> a
    android.opengl.GLSurfaceView$EGLConfigChooser access$300(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory access$400(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> c
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory access$500(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> d
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper access$600(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> e
    int access$700(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager access$800() -> d
    boolean access$900(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> g
    android.opengl.GLSurfaceView$Renderer access$1000(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18) -> h
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$1 -> com.badlogic.gdx.backends.android.a.k:
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$BaseConfigChooser -> com.badlogic.gdx.backends.android.a.l:
    int[] mConfigSpec -> a
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> b
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int[] filterConfigSpec(int[]) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$ComponentSizeChooser -> com.badlogic.gdx.backends.android.a.m:
    int[] mValue -> j
    int mRedSize -> c
    int mGreenSize -> d
    int mBlueSize -> e
    int mAlphaSize -> f
    int mDepthSize -> g
    int mStencilSize -> h
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$DefaultContextFactory -> com.badlogic.gdx.backends.android.a.n:
    int EGL_CONTEXT_CLIENT_VERSION -> b
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> a
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$DefaultWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.o:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLContextFactory -> com.badlogic.gdx.backends.android.a.p:
    javax.microedition.khronos.egl.EGLContext createContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig) -> a
    void destroyContext(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLContext) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EGLWindowSurfaceFactory -> com.badlogic.gdx.backends.android.a.q:
    javax.microedition.khronos.egl.EGLSurface createWindowSurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,java.lang.Object) -> a
    void destroySurface(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLSurface) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EglHelper -> com.badlogic.gdx.backends.android.a.r:
    java.lang.ref.WeakReference mGLSurfaceViewWeakRef -> f
    javax.microedition.khronos.egl.EGL10 mEgl -> a
    javax.microedition.khronos.egl.EGLDisplay mEglDisplay -> b
    javax.microedition.khronos.egl.EGLSurface mEglSurface -> c
    javax.microedition.khronos.egl.EGLConfig mEglConfig -> d
    javax.microedition.khronos.egl.EGLContext mEglContext -> e
    void start() -> a
    boolean createSurface() -> b
    javax.microedition.khronos.opengles.GL createGL() -> c
    int swap() -> d
    void destroySurface() -> e
    void destroySurfaceImp() -> g
    void finish() -> f
    void throwEglException(java.lang.String) -> a
    void throwEglException(java.lang.String,int) -> a
    void logEglErrorAsWarning(java.lang.String,java.lang.String,int) -> a
    java.lang.String getErrorString(int) -> a
    java.lang.String formatEglError(java.lang.String,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread -> com.badlogic.gdx.backends.android.a.s:
    boolean mShouldExit -> a
    boolean mExited -> b
    boolean mRequestPaused -> c
    boolean mPaused -> d
    boolean mHasSurface -> e
    boolean mSurfaceIsBad -> f
    boolean mWaitingForSurface -> g
    boolean mHaveEglContext -> h
    boolean mHaveEglSurface -> i
    boolean mFinishedCreatingEglSurface -> j
    boolean mShouldReleaseEglContext -> k
    int mWidth -> l
    int mHeight -> m
    int mRenderMode -> n
    boolean mRequestRender -> o
    boolean mRenderComplete -> p
    java.util.ArrayList mEventQueue -> q
    boolean mSizeChanged -> r
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$EglHelper mEglHelper -> s
    java.lang.ref.WeakReference mGLSurfaceViewWeakRef -> t
    void run() -> run
    void stopEglSurfaceLocked() -> j
    void stopEglContextLocked() -> k
    void guardedRun() -> l
    boolean ableToDraw() -> a
    boolean readyToDraw() -> m
    void setRenderMode(int) -> a
    int getRenderMode() -> b
    void requestRender() -> c
    void surfaceCreated() -> d
    void surfaceDestroyed() -> e
    void onPause() -> f
    void onResume() -> g
    void onWindowResize(int,int) -> a
    void requestExitAndWait() -> h
    void requestReleaseEglContextLocked() -> i
    boolean access$1102(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread,boolean) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThreadManager -> com.badlogic.gdx.backends.android.a.t:
    java.lang.String TAG -> a
    boolean mGLESVersionCheckComplete -> b
    int mGLESVersion -> c
    boolean mGLESDriverCheckComplete -> d
    boolean mMultipleGLESContextsAllowed -> e
    boolean mLimitedGLESContexts -> f
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread mEglOwner -> g
    void threadExiting(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> a
    boolean tryAcquireEglContextLocked(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> b
    void releaseEglContextLocked(com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLThread) -> c
    boolean shouldReleaseEGLContextWhenPausing() -> a
    boolean shouldTerminateEGLWhenPausing() -> b
    void checkGLDriver(javax.microedition.khronos.opengles.GL10) -> a
    void checkGLESVersion() -> c
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$GLWrapper -> com.badlogic.gdx.backends.android.a.u:
    javax.microedition.khronos.opengles.GL wrap(javax.microedition.khronos.opengles.GL) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$LogWriter -> com.badlogic.gdx.backends.android.a.v:
    java.lang.StringBuilder mBuilder -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18$SimpleEGLConfigChooser -> com.badlogic.gdx.backends.android.a.w:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18 this$0 -> j
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> com.badlogic.gdx.backends.android.a.x:
    int mRedSize -> a
    int mGreenSize -> b
    int mBlueSize -> c
    int mAlphaSize -> d
    int mDepthSize -> e
    int mStencilSize -> f
    int mNumSamples -> g
    int[] mConfigAttribs -> h
    int[] mValue -> i
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay) -> chooseConfig
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> com.badlogic.gdx.backends.android.a.y:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> com.badlogic.gdx.backends.android.a.z:
    int width -> a
    int height -> b
com.badlogic.gdx.files.FileHandle -> com.badlogic.gdx.d.a:
    java.io.File file -> b
    com.badlogic.gdx.Files$FileType type -> c
    java.lang.String path() -> f
    java.lang.String name() -> g
    java.lang.String extension() -> h
    java.lang.String nameWithoutExtension() -> i
    java.lang.String pathWithoutExtension() -> j
    com.badlogic.gdx.Files$FileType type() -> k
    java.io.File file() -> e
    java.io.InputStream read() -> b
    java.io.BufferedInputStream read(int) -> a
    java.io.Reader reader(java.lang.String) -> c
    java.io.BufferedReader reader(int) -> b
    byte[] readBytes() -> l
    int estimateLength() -> m
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> b
    com.badlogic.gdx.files.FileHandle parent() -> a
    boolean exists() -> c
    long length() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.badlogic.gdx.files.FileHandle$1 -> com.badlogic.gdx.d.b:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> com.badlogic.gdx.graphics.a:
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    float near -> h
    float far -> i
    float viewportWidth -> j
    float viewportHeight -> k
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.collision.Ray ray -> n
    void update() -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
com.badlogic.gdx.graphics.Color -> com.badlogic.gdx.graphics.b:
    com.badlogic.gdx.graphics.Color CLEAR -> a
    com.badlogic.gdx.graphics.Color WHITE -> b
    com.badlogic.gdx.graphics.Color BLACK -> c
    com.badlogic.gdx.graphics.Color RED -> d
    com.badlogic.gdx.graphics.Color GREEN -> e
    com.badlogic.gdx.graphics.Color BLUE -> f
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> g
    com.badlogic.gdx.graphics.Color GRAY -> h
    com.badlogic.gdx.graphics.Color DARK_GRAY -> i
    com.badlogic.gdx.graphics.Color PINK -> j
    com.badlogic.gdx.graphics.Color ORANGE -> k
    com.badlogic.gdx.graphics.Color YELLOW -> l
    com.badlogic.gdx.graphics.Color MAGENTA -> m
    com.badlogic.gdx.graphics.Color CYAN -> n
    com.badlogic.gdx.graphics.Color OLIVE -> o
    com.badlogic.gdx.graphics.Color PURPLE -> p
    com.badlogic.gdx.graphics.Color MAROON -> q
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color NAVY -> s
    com.badlogic.gdx.graphics.Color tmp -> t
    float r -> u
    float g -> v
    float b -> w
    float a -> x
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> b
    com.badlogic.gdx.graphics.Color clamp() -> a
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    float toFloatBits() -> b
    int toIntBits() -> c
    java.lang.String toString() -> toString
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> a
    float toFloatBits(float,float,float,float) -> b
    int rgba8888(float,float,float,float) -> c
    void rgb888ToColor(com.badlogic.gdx.graphics.Color,int) -> a
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> b
com.badlogic.gdx.graphics.Colors -> com.badlogic.gdx.graphics.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> a
com.badlogic.gdx.graphics.GL20 -> com.badlogic.gdx.graphics.d:
    void glBindTexture(int,int) -> glBindTexture
    void glBlendFunc(int,int) -> glBlendFunc
    void glClear(int) -> glClear
    void glClearColor(float,float,float,float) -> glClearColor
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> glCompressedTexImage2D
    void glDeleteTextures(int,java.nio.IntBuffer) -> glDeleteTextures
    void glDepthMask(boolean) -> glDepthMask
    void glDisable(int) -> glDisable
    void glDrawArrays(int,int,int) -> glDrawArrays
    void glDrawElements(int,int,int,java.nio.Buffer) -> glDrawElements
    void glEnable(int) -> glEnable
    void glGenTextures(int,java.nio.IntBuffer) -> glGenTextures
    void glGetIntegerv(int,java.nio.IntBuffer) -> glGetIntegerv
    java.lang.String glGetString(int) -> glGetString
    void glPixelStorei(int,int) -> glPixelStorei
    void glScissor(int,int,int,int) -> glScissor
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> glTexImage2D
    void glTexParameterf(int,int,float) -> glTexParameterf
    void glViewport(int,int,int,int) -> glViewport
    void glAttachShader(int,int) -> glAttachShader
    void glBindBuffer(int,int) -> glBindBuffer
    void glBindFramebuffer(int,int) -> glBindFramebuffer
    void glBindRenderbuffer(int,int) -> glBindRenderbuffer
    void glBufferData(int,int,java.nio.Buffer,int) -> glBufferData
    void glBufferSubData(int,int,int,java.nio.Buffer) -> glBufferSubData
    int glCheckFramebufferStatus(int) -> glCheckFramebufferStatus
    void glCompileShader(int) -> glCompileShader
    int glCreateProgram() -> glCreateProgram
    int glCreateShader(int) -> glCreateShader
    void glDeleteBuffers(int,java.nio.IntBuffer) -> glDeleteBuffers
    void glDeleteFramebuffers(int,java.nio.IntBuffer) -> glDeleteFramebuffers
    void glDeleteProgram(int) -> glDeleteProgram
    void glDeleteRenderbuffers(int,java.nio.IntBuffer) -> glDeleteRenderbuffers
    void glDeleteShader(int) -> glDeleteShader
    void glDisableVertexAttribArray(int) -> glDisableVertexAttribArray
    void glDrawElements(int,int,int,int) -> glDrawElements
    void glEnableVertexAttribArray(int) -> glEnableVertexAttribArray
    void glFramebufferRenderbuffer(int,int,int,int) -> glFramebufferRenderbuffer
    void glFramebufferTexture2D(int,int,int,int,int) -> glFramebufferTexture2D
    void glGenBuffers(int,java.nio.IntBuffer) -> glGenBuffers
    void glGenerateMipmap(int) -> glGenerateMipmap
    void glGenFramebuffers(int,java.nio.IntBuffer) -> glGenFramebuffers
    void glGenRenderbuffers(int,java.nio.IntBuffer) -> glGenRenderbuffers
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveAttrib
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.Buffer) -> glGetActiveUniform
    int glGetAttribLocation(int,java.lang.String) -> glGetAttribLocation
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> glGetProgramiv
    java.lang.String glGetProgramInfoLog(int) -> glGetProgramInfoLog
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> glGetShaderiv
    java.lang.String glGetShaderInfoLog(int) -> glGetShaderInfoLog
    int glGetUniformLocation(int,java.lang.String) -> glGetUniformLocation
    void glLinkProgram(int) -> glLinkProgram
    void glRenderbufferStorage(int,int,int,int) -> glRenderbufferStorage
    void glShaderSource(int,java.lang.String) -> glShaderSource
    void glUniform1i(int,int) -> glUniform1i
    void glUniformMatrix4fv(int,int,boolean,java.nio.FloatBuffer) -> glUniformMatrix4fv
    void glUseProgram(int) -> glUseProgram
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> glVertexAttribPointer
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> glVertexAttribPointer
com.badlogic.gdx.graphics.GL30 -> com.badlogic.gdx.graphics.e:
com.badlogic.gdx.graphics.GLTexture -> com.badlogic.gdx.graphics.f:
    java.nio.IntBuffer buffer -> g
    int glTarget -> a
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    void bind() -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap getUWrap() -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap getVWrap() -> f
    int getTextureObjectHandle() -> g
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> a
    void delete() -> h
    void dispose() -> c
    com.badlogic.gdx.graphics.TextureData createTextureData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
    int createGLHandle() -> i
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> a
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> a
com.badlogic.gdx.graphics.Mesh -> com.badlogic.gdx.graphics.g:
    java.util.Map meshes -> a
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> b
    com.badlogic.gdx.graphics.glutils.IndexData indices -> c
    boolean autoBind -> d
    boolean isVertexArray -> e
    com.badlogic.gdx.math.Vector3 tmpV -> f
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> a
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> a
    int getNumIndices() -> a
    int getNumVertices() -> b
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> b
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> a
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> a
    void dispose() -> c
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> a
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> d
    java.nio.FloatBuffer getVerticesBuffer() -> e
    java.nio.ShortBuffer getIndicesBuffer() -> f
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> a
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> a
    void clearAllMeshes(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> g
com.badlogic.gdx.graphics.Mesh$VertexDataType -> com.badlogic.gdx.graphics.h:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] values() -> values
    com.badlogic.gdx.graphics.Mesh$VertexDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.OrthographicCamera -> com.badlogic.gdx.graphics.i:
    float zoom -> m
    com.badlogic.gdx.math.Vector3 tmp -> n
    void update() -> a
    void update(boolean) -> a
com.badlogic.gdx.graphics.Pixmap -> com.badlogic.gdx.graphics.j:
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> c
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> a
    int color -> b
    boolean disposed -> d
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> a
    void setColor(float,float,float,float) -> a
    void fill() -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> a
    int getWidth() -> b
    int getHeight() -> d
    void dispose() -> c
    int getGLFormat() -> e
    int getGLInternalFormat() -> f
    int getGLType() -> g
    java.nio.ByteBuffer getPixels() -> h
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> i
    com.badlogic.gdx.graphics.Pixmap$Blending getBlending() -> j
com.badlogic.gdx.graphics.Pixmap$Blending -> com.badlogic.gdx.graphics.k:
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Blending valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.Pixmap$Format -> com.badlogic.gdx.graphics.l:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format[] values() -> values
    com.badlogic.gdx.graphics.Pixmap$Format valueOf(java.lang.String) -> valueOf
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
com.badlogic.gdx.graphics.PixmapIO -> com.badlogic.gdx.graphics.m:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> com.badlogic.gdx.graphics.n:
    byte[] writeBuffer -> a
    byte[] readBuffer -> b
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> com.badlogic.gdx.graphics.o:
    com.badlogic.gdx.assets.AssetManager assetManager -> i
    java.util.Map managedTextures -> g
    com.badlogic.gdx.graphics.TextureData data -> h
    void load(com.badlogic.gdx.graphics.TextureData) -> a
    void reload() -> j
    int getWidth() -> k
    int getHeight() -> l
    com.badlogic.gdx.graphics.TextureData getTextureData() -> m
    boolean isManaged() -> n
    void dispose() -> c
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> a
    void clearAllTextures(com.badlogic.gdx.Application) -> a
    void invalidateAllTextures(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> o
com.badlogic.gdx.graphics.Texture$1 -> com.badlogic.gdx.graphics.p:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> com.badlogic.gdx.graphics.q:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> g
    int glEnum -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureFilter valueOf(java.lang.String) -> valueOf
    boolean isMipMap() -> a
    int getGLEnum() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> com.badlogic.gdx.graphics.r:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> a
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> c
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap[] values() -> values
    com.badlogic.gdx.graphics.Texture$TextureWrap valueOf(java.lang.String) -> valueOf
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureData -> com.badlogic.gdx.graphics.s:
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    void consumeCustomData(int) -> a
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
com.badlogic.gdx.graphics.TextureData$TextureDataType -> com.badlogic.gdx.graphics.t:
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> b
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] values() -> values
    com.badlogic.gdx.graphics.TextureData$TextureDataType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.VertexAttribute -> com.badlogic.gdx.graphics.u:
    int usage -> a
    int numComponents -> b
    boolean normalized -> c
    int type -> d
    int offset -> e
    java.lang.String alias -> f
    int unit -> g
    int usageIndex -> h
    com.badlogic.gdx.graphics.VertexAttribute Position() -> a
    com.badlogic.gdx.graphics.VertexAttribute TexCoords(int) -> a
    com.badlogic.gdx.graphics.VertexAttribute Normal() -> b
    com.badlogic.gdx.graphics.VertexAttribute Color() -> c
    com.badlogic.gdx.graphics.VertexAttribute ColorPacked() -> d
    com.badlogic.gdx.graphics.VertexAttribute ColorUnpacked() -> e
    com.badlogic.gdx.graphics.VertexAttribute Tangent() -> f
    com.badlogic.gdx.graphics.VertexAttribute Binormal() -> g
    com.badlogic.gdx.graphics.VertexAttribute BoneWeight(int) -> b
    boolean equals(java.lang.Object) -> equals
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> a
    int getKey() -> h
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.VertexAttributes -> com.badlogic.gdx.graphics.v:
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
    int vertexSize -> a
    long mask -> c
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> d
    int calculateOffsets() -> b
    int size() -> a
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> com.badlogic.gdx.graphics.w:
    java.lang.Object[] array -> a
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> b
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> c
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> com.badlogic.gdx.graphics.x:
    java.lang.Object[] array -> c
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.graphics.g2d.Batch -> com.badlogic.gdx.graphics.g2d.a:
    void begin() -> a
    void end() -> b
    void setColor(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void flush() -> e
    com.badlogic.gdx.math.Matrix4 getProjectionMatrix() -> f
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> g
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
com.badlogic.gdx.graphics.g2d.BitmapFont -> com.badlogic.gdx.graphics.g2d.b:
    char[] xChars -> a
    char[] capChars -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion[] regions -> d
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> f
    boolean flipped -> g
    boolean integer -> h
    boolean ownsTexture -> i
    boolean markupEnabled -> e
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds(java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getMultiLineBounds(java.lang.CharSequence,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getWrappedBounds(java.lang.CharSequence,float,com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
    int computeVisibleGlyphs(java.lang.CharSequence,int,int,float) -> a
    void setScale(float,float) -> a
    void setScale(float) -> a
    float getScaleX() -> a
    float getScaleY() -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion[] getRegions() -> d
    float getCapHeight() -> e
    float getDescent() -> f
    boolean isFlipped() -> g
    void dispose() -> c
    boolean usesIntegerPositions() -> h
    int indexOf(java.lang.CharSequence,char,int) -> a
    boolean isWhitespace(char) -> a
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> com.badlogic.gdx.graphics.g2d.c:
    java.lang.String imagePath -> a
    java.lang.String[] imagePaths -> b
    com.badlogic.gdx.files.FileHandle fontFile -> c
    boolean flipped -> d
    float lineHeight -> e
    float capHeight -> f
    float ascent -> g
    float descent -> h
    float down -> i
    float scaleX -> j
    float scaleY -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> l
    float spaceWidth -> m
    float xHeight -> n
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> a
    java.lang.String getImagePath(int) -> a
    java.lang.String[] getImagePaths() -> b
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> com.badlogic.gdx.graphics.g2d.d:
    int id -> a
    int srcX -> b
    int srcY -> c
    int width -> d
    int height -> e
    float u -> f
    float v -> g
    float u2 -> h
    float v2 -> i
    int xoffset -> j
    int yoffset -> k
    int xadvance -> l
    byte[][] kerning -> m
    int page -> n
    int getKerning(char) -> a
    void setKerning(int,int) -> a
com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment -> com.badlogic.gdx.graphics.g2d.e:
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment LEFT -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment CENTER -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment RIGHT -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment[] values() -> values
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds -> com.badlogic.gdx.graphics.g2d.f:
    float width -> a
    float height -> b
    void set(com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds) -> a
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> com.badlogic.gdx.graphics.g2d.g:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] vertexData -> b
    int[] idx -> c
    int[] tmpGlyphCount -> d
    float x -> e
    float y -> f
    float color -> g
    float previousColor -> h
    com.badlogic.gdx.graphics.Color tempColor -> i
    com.badlogic.gdx.graphics.Color hexColor -> j
    com.badlogic.gdx.utils.StringBuilder colorBuffer -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds textBounds -> l
    boolean integer -> m
    int glyphCount -> n
    com.badlogic.gdx.utils.IntArray[] glyphIndices -> o
    void setPosition(float,float) -> a
    void translate(float,float) -> b
    void setColors(com.badlogic.gdx.graphics.Color) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void clear() -> a
    int countGlyphs(java.lang.CharSequence,int,int) -> a
    void requireSequence(java.lang.CharSequence,int,int) -> b
    void require(int,int) -> a
    int parseAndSetColor(java.lang.CharSequence,int,int) -> c
    float addToCache(java.lang.CharSequence,float,float,int,int) -> a
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addMultiLineText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds setWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds addWrappedText(java.lang.CharSequence,float,float,float,com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment) -> d
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds getBounds() -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> c
    void setUseIntegerPositions(boolean) -> a
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long basePtr -> a
    int width -> b
    int height -> c
    int format -> d
    java.nio.ByteBuffer pixelPtr -> e
    long[] nativeData -> f
    void convert(int) -> b
    void dispose() -> c
    void clear(int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> a
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> a
    java.nio.ByteBuffer getPixels() -> a
    int getHeight() -> b
    int getWidth() -> d
    int getFormat() -> e
    int getGLInternalFormat() -> f
    int getGLFormat() -> g
    int getGLType() -> h
    java.nio.ByteBuffer load(long[],byte[],int,int) -> load
    java.nio.ByteBuffer newPixmap(long[],int,int,int) -> newPixmap
    void free(long) -> free
    void clear(long,int) -> clear
    void drawPixmap(long,long,int,int,int,int,int,int,int,int) -> drawPixmap
    void setBlend(int) -> setBlend
    void setScale(int) -> setScale
    java.lang.String getFailureReason() -> getFailureReason
com.badlogic.gdx.graphics.g2d.NinePatch -> com.badlogic.gdx.graphics.g2d.h:
    com.badlogic.gdx.graphics.Color tmpDrawColor -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    int bottomLeft -> c
    int bottomCenter -> d
    int bottomRight -> e
    int middleLeft -> f
    int middleCenter -> g
    int middleRight -> h
    int topLeft -> i
    int topCenter -> j
    int topRight -> k
    float leftWidth -> l
    float rightWidth -> m
    float middleWidth -> n
    float middleHeight -> o
    float topHeight -> p
    float bottomHeight -> q
    float[] vertices -> r
    int idx -> s
    com.badlogic.gdx.graphics.Color color -> t
    int padLeft -> u
    int padRight -> v
    int padTop -> w
    int padBottom -> x
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> a
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,float,boolean,boolean) -> a
    void set(int,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    float getRightWidth() -> b
    float getTopHeight() -> c
    float getBottomHeight() -> d
    float getTotalWidth() -> e
    float getTotalHeight() -> f
    void setPadding(int,int,int,int) -> a
    float getPadLeft() -> g
    float getPadRight() -> h
    float getPadTop() -> i
    float getPadBottom() -> j
com.badlogic.gdx.graphics.g2d.ParticleEffect -> com.badlogic.gdx.graphics.g2d.i:
    com.badlogic.gdx.utils.Array emitters -> a
    boolean ownsTexture -> b
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    void loadEmitters(com.badlogic.gdx.files.FileHandle) -> a
    void loadEmitterImages(com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> a
    void loadEmitterImages(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.Texture loadTexture(com.badlogic.gdx.files.FileHandle) -> c
    void dispose() -> c
com.badlogic.gdx.graphics.g2d.ParticleEmitter -> com.badlogic.gdx.graphics.g2d.j:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue delayValue -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeOffsetValue -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue durationValue -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue lifeValue -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue emissionValue -> f
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue scaleValue -> g
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue rotationValue -> h
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue velocityValue -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue angleValue -> j
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue windValue -> k
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue gravityValue -> l
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue transparencyValue -> m
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue tintValue -> n
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue xOffsetValue -> o
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue yOffsetValue -> p
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnWidthValue -> q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnHeightValue -> r
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue spawnShapeValue -> s
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle[] particles -> u
    int minParticleCount -> v
    int maxParticleCount -> w
    java.lang.String name -> x
    java.lang.String imagePath -> y
    int activeCount -> z
    boolean[] active -> A
    float duration -> a
    boolean attached -> B
    boolean continuous -> C
    boolean aligned -> D
    boolean behind -> E
    boolean additive -> F
    boolean premultipliedAlpha -> G
    void initialize() -> c
    void setMaxParticleCount(int) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> a
    void setMinParticleCount(int) -> b
    java.lang.String getImagePath() -> b
    void setImagePath(java.lang.String) -> a
    void load(java.io.BufferedReader) -> a
    java.lang.String readString(java.lang.String) -> b
    java.lang.String readString(java.io.BufferedReader,java.lang.String) -> a
    boolean readBoolean(java.lang.String) -> c
    boolean readBoolean(java.io.BufferedReader,java.lang.String) -> b
    int readInt(java.io.BufferedReader,java.lang.String) -> c
    float readFloat(java.io.BufferedReader,java.lang.String) -> d
com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue -> com.badlogic.gdx.graphics.g2d.k:
    float[] temp -> d
    float[] colors -> e
    float[] timeline -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle -> com.badlogic.gdx.graphics.g2d.l:
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue -> com.badlogic.gdx.graphics.g2d.m:
    boolean active -> b
    boolean alwaysActive -> c
    void setAlwaysActive(boolean) -> a
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue -> com.badlogic.gdx.graphics.g2d.n:
    float lowMin -> a
    float lowMax -> d
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue -> com.badlogic.gdx.graphics.g2d.o:
    float[] scaling -> d
    float[] timeline -> a
    float highMin -> e
    float highMax -> f
    boolean relative -> g
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide -> com.badlogic.gdx.graphics.g2d.p:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide both -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide top -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide bottom -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape -> com.badlogic.gdx.graphics.g2d.q:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape point -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape line -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape square -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape ellipse -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] $VALUES -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] values() -> values
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue -> com.badlogic.gdx.graphics.g2d.r:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape shape -> a
    boolean edges -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide side -> e
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.PolygonRegion -> com.badlogic.gdx.graphics.g2d.s:
    float[] textureCoords -> a
    float[] vertices -> b
    short[] triangles -> c
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> d
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader -> com.badlogic.gdx.graphics.g2d.t:
    com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters defaultParameters -> a
    com.badlogic.gdx.math.EarClippingTriangulator triangulator -> b
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> a
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.files.FileHandle) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters -> com.badlogic.gdx.graphics.g2d.u:
    java.lang.String texturePrefix -> b
    int readerBuffer -> c
    java.lang.String[] textureExtensions -> d
com.badlogic.gdx.graphics.g2d.Sprite -> com.badlogic.gdx.graphics.g2d.v:
    float[] vertices -> a
    com.badlogic.gdx.graphics.Color color -> d
    float x -> e
    float y -> f
    float width -> b
    float height -> c
    float originX -> g
    float originY -> h
    float rotation -> i
    float scaleX -> j
    float scaleY -> k
    boolean dirty -> s
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> a
    void setX(float) -> a
    void setY(float) -> b
    void setCenterX(float) -> c
    void setCenterY(float) -> d
    void setCenter(float,float) -> b
    void translateX(float) -> e
    void translateY(float) -> f
    void translate(float,float) -> c
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setAlpha(float) -> g
    void setColor(float,float,float,float) -> b
    void setOrigin(float,float) -> d
    void setOriginCenter() -> a
    void setRotation(float) -> h
    void rotate90(boolean) -> a
    void setScale(float,float) -> e
    float[] getVertices() -> b
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> a
    float getX() -> c
    float getY() -> d
    float getWidth() -> e
    float getHeight() -> f
    float getOriginX() -> g
    float getOriginY() -> h
    com.badlogic.gdx.graphics.Color getColor() -> i
    void setRegion(float,float,float,float) -> c
    void flip(boolean,boolean) -> a
com.badlogic.gdx.graphics.g2d.SpriteBatch -> com.badlogic.gdx.graphics.g2d.w:
    com.badlogic.gdx.graphics.Mesh mesh -> e
    float[] vertices -> f
    int idx -> g
    com.badlogic.gdx.graphics.Texture lastTexture -> h
    float invTexWidth -> i
    float invTexHeight -> j
    boolean drawing -> k
    com.badlogic.gdx.math.Matrix4 transformMatrix -> l
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> m
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> n
    boolean blendingDisabled -> o
    int blendSrcFunc -> p
    int blendDstFunc -> q
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> r
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> s
    boolean ownsShader -> t
    float color -> a
    com.badlogic.gdx.graphics.Color tempColor -> u
    int renderCalls -> b
    int totalRenderCalls -> c
    int maxSpritesInBatch -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> h
    void begin() -> a
    void end() -> b
    void setColor(float,float,float,float) -> a
    com.badlogic.gdx.graphics.Color getColor() -> d
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> a
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> a
    void flush() -> e
    void dispose() -> c
    com.badlogic.gdx.math.Matrix4 getProjectionMatrix() -> f
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> g
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    void setupMatrices() -> j
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> a
    boolean isBlendingEnabled() -> i
com.badlogic.gdx.graphics.g2d.TextureAtlas -> com.badlogic.gdx.graphics.g2d.x:
    java.lang.String[] tuple -> a
    com.badlogic.gdx.utils.ObjectSet textures -> c
    com.badlogic.gdx.utils.Array regions -> d
    java.util.Comparator indexComparator -> b
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> a
    com.badlogic.gdx.utils.Array getRegions() -> a
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.Sprite newSprite(com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion) -> a
    void dispose() -> c
    java.lang.String readValue(java.io.BufferedReader) -> a
    int readTuple(java.io.BufferedReader) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$1 -> com.badlogic.gdx.graphics.g2d.y:
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> com.badlogic.gdx.graphics.g2d.z:
    int index -> a
    java.lang.String name -> b
    float offsetX -> c
    float offsetY -> d
    int packedWidth -> e
    int packedHeight -> f
    int originalWidth -> g
    int originalHeight -> h
    boolean rotate -> i
    int[] splits -> j
    int[] pads -> k
    void flip(boolean,boolean) -> a
    float getRotatedPackedWidth() -> a
    float getRotatedPackedHeight() -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> com.badlogic.gdx.graphics.g2d.aa:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> d
    float originalOffsetX -> e
    float originalOffsetY -> f
    void setX(float) -> a
    void setY(float) -> b
    void setBounds(float,float,float,float) -> a
    void setSize(float,float) -> a
    void setOrigin(float,float) -> d
    void setOriginCenter() -> a
    void flip(boolean,boolean) -> a
    void rotate90(boolean) -> a
    float getX() -> c
    float getY() -> d
    float getOriginX() -> g
    float getOriginY() -> h
    float getWidth() -> e
    float getHeight() -> f
    float getWidthRatio() -> j
    float getHeightRatio() -> k
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> com.badlogic.gdx.graphics.g2d.ab:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getPages() -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> com.badlogic.gdx.graphics.g2d.ac:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    com.badlogic.gdx.graphics.Texture texture -> b
    float width -> c
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> com.badlogic.gdx.graphics.g2d.ad:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    int index -> b
    java.lang.String name -> c
    float offsetX -> d
    float offsetY -> e
    int originalWidth -> f
    int originalHeight -> g
    boolean rotate -> h
    int left -> i
    int top -> j
    int width -> k
    int height -> l
    boolean flip -> m
    int[] splits -> n
    int[] pads -> o
com.badlogic.gdx.graphics.g2d.TextureRegion -> com.badlogic.gdx.graphics.g2d.ae:
    com.badlogic.gdx.graphics.Texture texture -> l
    float u -> m
    float v -> n
    float u2 -> o
    float v2 -> p
    int regionWidth -> q
    int regionHeight -> r
    void setRegion(int,int,int,int) -> a
    void setRegion(float,float,float,float) -> c
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> a
    com.badlogic.gdx.graphics.Texture getTexture() -> l
    void setTexture(com.badlogic.gdx.graphics.Texture) -> a
    float getU() -> m
    float getV() -> n
    float getU2() -> o
    float getV2() -> p
    int getRegionX() -> q
    int getRegionY() -> r
    int getRegionWidth() -> s
    int getRegionHeight() -> t
    void flip(boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.Attribute -> com.badlogic.gdx.graphics.a.a:
    com.badlogic.gdx.utils.Array types -> b
    long type -> a
    long getAttributeType(java.lang.String) -> a
    java.lang.String getAttributeAlias(long) -> a
    long register(java.lang.String) -> b
    boolean equals(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.g3d.Attributes -> com.badlogic.gdx.graphics.a.b:
    long mask -> a
    com.badlogic.gdx.utils.Array attributes -> b
    boolean sorted -> c
    void sort() -> a
    void enable(long) -> c
    void set(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    boolean has(long) -> a
    int indexOf(long) -> b
    int compare(com.badlogic.gdx.graphics.g3d.Attribute,com.badlogic.gdx.graphics.g3d.Attribute) -> a
    java.util.Iterator iterator() -> iterator
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int compare(java.lang.Object,java.lang.Object) -> compare
com.badlogic.gdx.graphics.g3d.Material -> com.badlogic.gdx.graphics.a.c:
    int counter -> e
    java.lang.String id -> d
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.Model -> com.badlogic.gdx.graphics.a.d:
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.utils.Array nodes -> b
    com.badlogic.gdx.utils.Array animations -> c
    com.badlogic.gdx.utils.Array meshes -> d
    com.badlogic.gdx.utils.Array meshParts -> e
    com.badlogic.gdx.utils.Array disposables -> f
    com.badlogic.gdx.utils.ObjectMap nodePartBones -> g
    void load(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    void loadAnimations(java.lang.Iterable) -> a
    void loadNodes(java.lang.Iterable) -> b
    com.badlogic.gdx.graphics.g3d.model.Node loadNode(com.badlogic.gdx.graphics.g3d.model.Node,com.badlogic.gdx.graphics.g3d.model.data.ModelNode) -> a
    void loadMeshes(java.lang.Iterable) -> c
    void convertMesh(com.badlogic.gdx.graphics.g3d.model.data.ModelMesh) -> a
    void loadMaterials(java.lang.Iterable,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    com.badlogic.gdx.graphics.g3d.Material convertMaterial(com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> a
    java.lang.Iterable getManagedDisposables() -> a
    void dispose() -> c
    void calculateTransforms() -> b
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean) -> a
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute -> com.badlogic.gdx.graphics.a.a.a:
    long Type -> b
    boolean blended -> c
    int sourceFunction -> d
    int destFunction -> e
    float opacity -> f
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute -> com.badlogic.gdx.graphics.a.a.b:
    long Diffuse -> b
    long Specular -> c
    long Ambient -> d
    long Emissive -> e
    long Reflection -> f
    long AmbientLight -> g
    long Fog -> h
    long Mask -> i
    com.badlogic.gdx.graphics.Color color -> j
    boolean is(long) -> b
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute -> com.badlogic.gdx.graphics.a.a.c:
    long Shininess -> b
    long AlphaTest -> c
    float value -> d
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute -> com.badlogic.gdx.graphics.a.a.d:
    long Diffuse -> b
    long Specular -> c
    long Bump -> d
    long Normal -> e
    long Mask -> f
    com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor textureDescription -> g
    boolean is(long) -> b
    int hashCode() -> hashCode
com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader -> com.badlogic.gdx.graphics.a.b.a:
    com.badlogic.gdx.utils.BaseJsonReader reader -> c
    com.badlogic.gdx.math.Quaternion tempQ -> d
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData parseModel(com.badlogic.gdx.files.FileHandle) -> a
    void parseMeshes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> a
    int parseType(java.lang.String) -> b
    com.badlogic.gdx.graphics.VertexAttribute[] parseAttributes(com.badlogic.gdx.utils.JsonValue) -> a
    void parseMaterials(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue,java.lang.String) -> a
    int parseTextureUsage(java.lang.String) -> c
    com.badlogic.gdx.graphics.Color parseColor(com.badlogic.gdx.utils.JsonValue) -> b
    com.badlogic.gdx.math.Vector2 readVector2(com.badlogic.gdx.utils.JsonValue,float,float) -> a
    com.badlogic.gdx.utils.Array parseNodes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> b
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode parseNodesRecursively(com.badlogic.gdx.utils.JsonValue) -> c
    void parseAnimations(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> c
com.badlogic.gdx.graphics.g3d.loader.MtlLoader -> com.badlogic.gdx.graphics.a.b.b:
    com.badlogic.gdx.utils.Array materials -> a
    void load(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial getMaterial(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.loader.ObjLoader -> com.badlogic.gdx.graphics.a.b.c:
    boolean logWarning -> c
    com.badlogic.gdx.utils.FloatArray verts -> d
    com.badlogic.gdx.utils.FloatArray norms -> e
    com.badlogic.gdx.utils.FloatArray uvs -> f
    com.badlogic.gdx.utils.Array groups -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,boolean) -> a
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group setActiveGroup(java.lang.String) -> b
    int getIndex(java.lang.String,int) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> a
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group -> com.badlogic.gdx.graphics.a.b.d:
    java.lang.String name -> a
    java.lang.String materialName -> b
    com.badlogic.gdx.utils.Array faces -> c
    int numFaces -> d
    boolean hasNorms -> e
    boolean hasUVs -> f
    com.badlogic.gdx.graphics.g3d.Material mat -> g
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader this$0 -> h
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters -> com.badlogic.gdx.graphics.a.b.e:
    boolean flipV -> c
com.badlogic.gdx.graphics.g3d.model.Animation -> com.badlogic.gdx.graphics.a.c.a:
    java.lang.String id -> a
    float duration -> b
    com.badlogic.gdx.utils.Array nodeAnimations -> c
com.badlogic.gdx.graphics.g3d.model.MeshPart -> com.badlogic.gdx.graphics.a.c.b:
    java.lang.String id -> a
    int primitiveType -> b
    int indexOffset -> c
    int numVertices -> d
    com.badlogic.gdx.graphics.Mesh mesh -> e
    boolean equals(com.badlogic.gdx.graphics.g3d.model.MeshPart) -> a
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.g3d.model.Node -> com.badlogic.gdx.graphics.a.c.c:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.g3d.model.Node parent -> b
    com.badlogic.gdx.utils.Array children -> c
    boolean isAnimated -> d
    com.badlogic.gdx.math.Vector3 translation -> e
    com.badlogic.gdx.math.Quaternion rotation -> f
    com.badlogic.gdx.math.Vector3 scale -> g
    com.badlogic.gdx.math.Matrix4 localTransform -> h
    com.badlogic.gdx.math.Matrix4 globalTransform -> i
    com.badlogic.gdx.utils.Array parts -> j
    com.badlogic.gdx.math.Matrix4 calculateLocalTransform() -> a
    com.badlogic.gdx.math.Matrix4 calculateWorldTransform() -> b
    void calculateTransforms(boolean) -> a
    void calculateBoneTransforms(boolean) -> b
    com.badlogic.gdx.graphics.g3d.model.Node getNode(com.badlogic.gdx.utils.Array,java.lang.String,boolean,boolean) -> a
com.badlogic.gdx.graphics.g3d.model.NodeAnimation -> com.badlogic.gdx.graphics.a.c.d:
    com.badlogic.gdx.graphics.g3d.model.Node node -> a
    com.badlogic.gdx.utils.Array keyframes -> b
com.badlogic.gdx.graphics.g3d.model.NodeKeyframe -> com.badlogic.gdx.graphics.a.c.e:
    float keytime -> a
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.math.Vector3 scale -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
com.badlogic.gdx.graphics.g3d.model.NodePart -> com.badlogic.gdx.graphics.a.c.f:
    com.badlogic.gdx.graphics.g3d.model.MeshPart meshPart -> a
    com.badlogic.gdx.graphics.g3d.Material material -> b
    com.badlogic.gdx.utils.ArrayMap invBoneBindTransforms -> c
    com.badlogic.gdx.math.Matrix4[] bones -> d
    boolean enabled -> e
com.badlogic.gdx.graphics.g3d.model.data.ModelAnimation -> com.badlogic.gdx.graphics.a.c.a.a:
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array nodeAnimations -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelData -> com.badlogic.gdx.graphics.a.c.a.b:
    java.lang.String id -> a
    short[] version -> b
    com.badlogic.gdx.utils.Array meshes -> c
    com.badlogic.gdx.utils.Array materials -> d
    com.badlogic.gdx.utils.Array nodes -> e
    com.badlogic.gdx.utils.Array animations -> f
com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial -> com.badlogic.gdx.graphics.a.c.a.c:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.Color ambient -> b
    com.badlogic.gdx.graphics.Color diffuse -> c
    com.badlogic.gdx.graphics.Color specular -> d
    com.badlogic.gdx.graphics.Color emissive -> e
    com.badlogic.gdx.graphics.Color reflection -> f
    float shininess -> g
    float opacity -> h
    com.badlogic.gdx.utils.Array textures -> i
com.badlogic.gdx.graphics.g3d.model.data.ModelMesh -> com.badlogic.gdx.graphics.a.c.a.d:
    java.lang.String id -> a
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
    float[] vertices -> c
    com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart[] parts -> d
com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart -> com.badlogic.gdx.graphics.a.c.a.e:
    java.lang.String id -> a
    short[] indices -> b
    int primitiveType -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelNode -> com.badlogic.gdx.graphics.a.c.a.f:
    java.lang.String id -> a
    int boneId -> b
    com.badlogic.gdx.math.Vector3 translation -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
    com.badlogic.gdx.math.Vector3 scale -> e
    java.lang.String meshId -> f
    com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart[] parts -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode[] children -> h
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeAnimation -> com.badlogic.gdx.graphics.a.c.a.g:
    java.lang.String nodeId -> a
    com.badlogic.gdx.utils.Array keyframes -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeKeyframe -> com.badlogic.gdx.graphics.a.c.a.h:
    float keytime -> a
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.math.Vector3 scale -> c
    com.badlogic.gdx.math.Quaternion rotation -> d
com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart -> com.badlogic.gdx.graphics.a.c.a.i:
    java.lang.String materialId -> a
    java.lang.String meshPartId -> b
    com.badlogic.gdx.utils.ArrayMap bones -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelTexture -> com.badlogic.gdx.graphics.a.c.a.j:
    java.lang.String id -> a
    java.lang.String fileName -> b
    com.badlogic.gdx.math.Vector2 uvTranslation -> c
    com.badlogic.gdx.math.Vector2 uvScaling -> d
    int usage -> e
com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor -> com.badlogic.gdx.graphics.a.d.a:
    com.badlogic.gdx.graphics.GLTexture texture -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> e
    void set(com.badlogic.gdx.graphics.GLTexture,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> a
    void set(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> a
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.graphics.g3d.utils.TextureProvider -> com.badlogic.gdx.graphics.a.d.b:
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.utils.TextureProvider$AssetTextureProvider -> com.badlogic.gdx.graphics.a.d.c:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int PKM_HEADER_SIZE -> a
    int ETC1_RGB8_OES -> b
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getWidthPKM(java.nio.ByteBuffer,int) -> getWidthPKM
    int getHeightPKM(java.nio.ByteBuffer,int) -> getHeightPKM
    boolean isValidPKM(java.nio.ByteBuffer,int) -> isValidPKM
    void decodeImage(java.nio.ByteBuffer,int,java.nio.ByteBuffer,int,int,int,int) -> decodeImage
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.a:
    int width -> a
    int height -> b
    java.nio.ByteBuffer compressedData -> c
    int dataOffset -> d
    void checkNPOT() -> b
    boolean hasPKMHeader() -> a
    void dispose() -> c
    java.lang.String toString() -> toString
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.b:
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    boolean useMipMaps -> c
    int width -> d
    int height -> e
    boolean isPrepared -> f
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    boolean isPrepared() -> b
    void prepare() -> c
    void consumeCustomData(int) -> a
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
com.badlogic.gdx.graphics.glutils.FileTextureData -> com.badlogic.gdx.graphics.glutils.c:
    boolean copyToPOT -> a
    com.badlogic.gdx.files.FileHandle file -> b
    int width -> c
    int height -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    com.badlogic.gdx.graphics.Pixmap pixmap -> f
    boolean useMipMaps -> g
    boolean isPrepared -> h
    boolean isPrepared() -> b
    void prepare() -> c
    com.badlogic.gdx.graphics.Pixmap ensurePot(com.badlogic.gdx.graphics.Pixmap) -> a
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    boolean disposePixmap() -> e
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCustomData(int) -> a
com.badlogic.gdx.graphics.glutils.FrameBuffer -> com.badlogic.gdx.graphics.glutils.d:
    java.util.Map buffers -> f
    com.badlogic.gdx.graphics.Texture colorTexture -> a
    int defaultFramebufferHandle -> g
    boolean defaultFramebufferHandleInitialized -> h
    int framebufferHandle -> i
    int depthbufferHandle -> j
    int width -> b
    int height -> c
    boolean hasDepth -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> e
    void setupTexture() -> a
    void build() -> d
    void dispose() -> c
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> a
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> b
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> a
    java.lang.String getManagedStatus() -> b
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> com.badlogic.gdx.graphics.glutils.e:
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(com.badlogic.gdx.graphics.Color) -> a
    void color(float,float,float,float) -> a
    void vertex(float,float,float) -> a
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> com.badlogic.gdx.graphics.glutils.f:
    int primitiveType -> a
    int vertexIdx -> b
    int numSetTexCoords -> c
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    boolean ownsShader -> h
    int numTexCoords -> i
    int vertexSize -> j
    int normalOffset -> k
    int colorOffset -> l
    int texCoordOffset -> m
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    float[] vertices -> o
    java.lang.String[] shaderUniformNames -> p
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> b
    void begin(com.badlogic.gdx.math.Matrix4,int) -> a
    void color(com.badlogic.gdx.graphics.Color) -> a
    void color(float,float,float,float) -> a
    void vertex(float,float,float) -> a
    void flush() -> e
    void end() -> a
    int getNumVertices() -> b
    int getMaxVertices() -> c
    void dispose() -> d
    java.lang.String createVertexShader(boolean,boolean,int) -> c
    java.lang.String createFragmentShader(boolean,boolean,int) -> d
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> a
com.badlogic.gdx.graphics.glutils.IndexArray -> com.badlogic.gdx.graphics.glutils.g:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> com.badlogic.gdx.graphics.glutils.h:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.i:
    java.nio.IntBuffer tmpHandle -> a
    java.nio.ShortBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> d
    boolean isDirect -> e
    boolean isDirty -> f
    boolean isBound -> g
    int usage -> h
    int createBufferObject() -> h
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.IndexData -> com.badlogic.gdx.graphics.glutils.j:
    int getNumIndices() -> a
    int getNumMaxIndices() -> b
    void setIndices(short[],int,int) -> a
    java.nio.ShortBuffer getBuffer() -> d
    void bind() -> e
    void unbind() -> f
    void invalidate() -> g
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> com.badlogic.gdx.graphics.glutils.k:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> a
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
com.badlogic.gdx.graphics.glutils.PixmapTextureData -> com.badlogic.gdx.graphics.glutils.l:
    com.badlogic.gdx.graphics.Pixmap pixmap -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    boolean useMipMaps -> c
    boolean disposePixmap -> d
    boolean managed -> e
    boolean disposePixmap() -> e
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> d
    int getWidth() -> f
    int getHeight() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    boolean useMipMaps() -> i
    boolean isManaged() -> j
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> a
    void consumeCustomData(int) -> a
    boolean isPrepared() -> b
    void prepare() -> c
com.badlogic.gdx.graphics.glutils.ShaderProgram -> com.badlogic.gdx.graphics.glutils.m:
    boolean pedantic -> a
    com.badlogic.gdx.utils.ObjectMap shaders -> e
    java.lang.String log -> f
    boolean isCompiled -> g
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> h
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> i
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> j
    java.lang.String[] uniformNames -> k
    com.badlogic.gdx.utils.ObjectIntMap attributes -> l
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> m
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> n
    java.lang.String[] attributeNames -> o
    int program -> p
    int vertexShaderHandle -> q
    int fragmentShaderHandle -> r
    java.nio.FloatBuffer matrix -> s
    java.lang.String vertexShaderSource -> t
    java.lang.String fragmentShaderSource -> u
    boolean invalidated -> v
    java.nio.ByteBuffer buffer -> w
    java.nio.FloatBuffer floatBuffer -> x
    java.nio.IntBuffer intBuffer -> y
    int refCount -> z
    java.nio.IntBuffer intbuf -> b
    java.nio.IntBuffer params -> c
    java.nio.IntBuffer type -> d
    void compileShaders(java.lang.String,java.lang.String) -> a
    int loadShader(int,java.lang.String) -> a
    int linkProgram() -> g
    java.lang.String getLog() -> a
    boolean isCompiled() -> b
    int fetchAttributeLocation(java.lang.String) -> c
    int fetchUniformLocation(java.lang.String) -> d
    int fetchUniformLocation(java.lang.String,boolean) -> a
    void setUniformi(java.lang.String,int) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> a
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> a
    void setVertexAttribute(int,int,int,boolean,int,int) -> a
    void begin() -> d
    void end() -> e
    void dispose() -> c
    void disableVertexAttribute(java.lang.String) -> a
    void disableVertexAttribute(int) -> a
    void enableVertexAttribute(int) -> b
    void checkManaged() -> h
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> a
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> a
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> b
    java.lang.String getManagedStatus() -> f
    void fetchUniforms() -> i
    void fetchAttributes() -> j
    int getAttributeLocation(java.lang.String) -> b
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> com.badlogic.gdx.graphics.glutils.n:
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.math.Vector2 tmp -> f
    com.badlogic.gdx.graphics.Color color -> g
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> h
    boolean autoShapeType -> i
    float defaultRectLineWidth -> j
    void setColor(com.badlogic.gdx.graphics.Color) -> a
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> a
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> a
    void setAutoShapeType(boolean) -> a
    void begin() -> b
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> a
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> b
    void rect(float,float,float,float) -> a
    void rect(float,float,float,float,float,float,float,float,float) -> a
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> a
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> a
    void end() -> d
    void flush() -> e
    boolean isDrawing() -> f
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> com.badlogic.gdx.graphics.glutils.o:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> a
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> c
    int glType -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] values() -> values
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType valueOf(java.lang.String) -> valueOf
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> com.badlogic.gdx.graphics.glutils.p:
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    boolean isBound -> d
    void dispose() -> c
    java.nio.FloatBuffer getBuffer() -> a
    int getNumVertices() -> b
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> com.badlogic.gdx.graphics.glutils.q:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isStatic -> f
    int usage -> g
    boolean isDirty -> h
    boolean isBound -> i
    int createBufferObject() -> f
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    int getNumVertices() -> b
    java.nio.FloatBuffer getBuffer() -> a
    void bufferChanged() -> g
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void invalidate() -> e
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> com.badlogic.gdx.graphics.glutils.r:
    java.nio.IntBuffer tmpHandle -> a
    com.badlogic.gdx.graphics.VertexAttributes attributes -> b
    java.nio.FloatBuffer buffer -> c
    java.nio.ByteBuffer byteBuffer -> d
    int bufferHandle -> e
    boolean isDirect -> f
    boolean isStatic -> g
    int usage -> h
    boolean isDirty -> i
    boolean isBound -> j
    int createBufferObject() -> e
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    int getNumVertices() -> b
    java.nio.FloatBuffer getBuffer() -> a
    void bufferChanged() -> f
    void setVertices(float[],int,int) -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void dispose() -> c
com.badlogic.gdx.graphics.glutils.VertexData -> com.badlogic.gdx.graphics.glutils.s:
    int getNumVertices() -> b
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> d
    void setVertices(float[],int,int) -> a
    java.nio.FloatBuffer getBuffer() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> b
    void dispose() -> c
com.badlogic.gdx.math.EarClippingTriangulator -> com.badlogic.gdx.math.a:
    com.badlogic.gdx.utils.ShortArray indicesArray -> a
    short[] indices -> b
    float[] vertices -> c
    int vertexCount -> d
    com.badlogic.gdx.utils.IntArray vertexTypes -> e
    com.badlogic.gdx.utils.ShortArray triangles -> f
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[]) -> a
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[],int,int) -> a
    void triangulate() -> a
    int classifyVertex(int) -> a
    int findEarTip() -> b
    boolean isEarTip(int) -> b
    void cutEarTip(int) -> c
    int previousIndex(int) -> d
    int nextIndex(int) -> e
    boolean areVerticesClockwise(float[],int,int) -> b
    int computeSpannedAreaSign(float,float,float,float,float,float) -> a
com.badlogic.gdx.math.Frustum -> com.badlogic.gdx.math.b:
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> a
    float[] clipSpacePlanePointsArray -> b
    com.badlogic.gdx.math.Plane[] planes -> c
    com.badlogic.gdx.math.Vector3[] planePoints -> d
    float[] planePointsArray -> e
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.MathUtils -> com.badlogic.gdx.math.c:
    int ATAN2_DIM -> a
    float INV_ATAN2_DIM_MINUS_1 -> c
    java.util.Random random -> b
    float sin(float) -> a
    float cos(float) -> b
    float sinDeg(float) -> c
    float cosDeg(float) -> d
    int random(int) -> a
    int random(int,int) -> a
    int nextPowerOfTwo(int) -> b
    boolean isPowerOfTwo(int) -> c
com.badlogic.gdx.math.MathUtils$Sin -> com.badlogic.gdx.math.d:
    float[] table -> a
com.badlogic.gdx.math.Matrix3 -> com.badlogic.gdx.math.e:
    float[] val -> a
    float[] tmp -> b
    com.badlogic.gdx.math.Matrix3 idt() -> a
    com.badlogic.gdx.math.Matrix3 mul(com.badlogic.gdx.math.Matrix3) -> a
    com.badlogic.gdx.math.Matrix3 setToTranslation(float,float) -> a
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Matrix3 set(com.badlogic.gdx.math.Matrix3) -> b
    com.badlogic.gdx.math.Matrix3 trn(float,float) -> b
    com.badlogic.gdx.math.Matrix3 translate(float,float) -> c
    com.badlogic.gdx.math.Matrix3 rotate(float) -> a
    com.badlogic.gdx.math.Matrix3 rotateRad(float) -> b
    com.badlogic.gdx.math.Matrix3 scale(float,float) -> d
    void mul(float[],float[]) -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    float[] tmp -> a
    float[] val -> b
    com.badlogic.gdx.math.Quaternion quat -> c
    com.badlogic.gdx.math.Quaternion quat2 -> d
    com.badlogic.gdx.math.Vector3 l_vez -> e
    com.badlogic.gdx.math.Vector3 l_vex -> f
    com.badlogic.gdx.math.Vector3 l_vey -> g
    com.badlogic.gdx.math.Vector3 tmpVec -> h
    com.badlogic.gdx.math.Matrix4 tmpMat -> i
    com.badlogic.gdx.math.Vector3 right -> j
    com.badlogic.gdx.math.Vector3 tmpForward -> k
    com.badlogic.gdx.math.Vector3 tmpUp -> l
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Matrix4 set(float[]) -> a
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Quaternion,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float,float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> b
    com.badlogic.gdx.math.Matrix4 idt() -> a
    com.badlogic.gdx.math.Matrix4 inv() -> b
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    java.lang.String toString() -> toString
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix3) -> a
    void mul(float[],float[]) -> mul
    void prj(float[],float[],int,int,int) -> prj
    boolean inv(float[]) -> inv
    com.badlogic.gdx.math.Matrix4 translate(float,float,float) -> b
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Quaternion) -> a
    com.badlogic.gdx.math.Matrix4 scale(float,float,float) -> c
com.badlogic.gdx.math.Plane -> com.badlogic.gdx.math.f:
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.math.Quaternion -> com.badlogic.gdx.math.g:
    com.badlogic.gdx.math.Quaternion tmp1 -> e
    com.badlogic.gdx.math.Quaternion tmp2 -> f
    float x -> a
    float y -> b
    float z -> c
    float w -> d
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> a
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Quaternion) -> a
    java.lang.String toString() -> toString
    void toMatrix(float[]) -> a
    com.badlogic.gdx.math.Quaternion idt() -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.RandomXS128 -> com.badlogic.gdx.math.h:
    long seed0 -> a
    long seed1 -> b
    long nextLong() -> nextLong
    int next(int) -> next
    int nextInt() -> nextInt
    int nextInt(int) -> nextInt
    long nextLong(long) -> a
    double nextDouble() -> nextDouble
    float nextFloat() -> nextFloat
    boolean nextBoolean() -> nextBoolean
    void nextBytes(byte[]) -> nextBytes
    void setSeed(long) -> setSeed
    void setState(long,long) -> a
    long murmurHash3(long) -> b
com.badlogic.gdx.math.Rectangle -> com.badlogic.gdx.math.i:
    com.badlogic.gdx.math.Rectangle tmp -> a
    com.badlogic.gdx.math.Rectangle tmp2 -> b
    float x -> c
    float y -> d
    float width -> e
    float height -> f
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.Vector2 -> com.badlogic.gdx.math.j:
    com.badlogic.gdx.math.Vector2 X -> a
    com.badlogic.gdx.math.Vector2 Y -> b
    com.badlogic.gdx.math.Vector2 Zero -> c
    float x -> d
    float y -> e
    float len2() -> a
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 set(float,float) -> a
    com.badlogic.gdx.math.Vector2 sub(com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Vector2 sub(float,float) -> b
    com.badlogic.gdx.math.Vector2 add(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 add(float,float) -> c
    com.badlogic.gdx.math.Vector2 scl(float) -> a
    com.badlogic.gdx.math.Vector2 scl(float,float) -> d
    com.badlogic.gdx.math.Vector2 scl(com.badlogic.gdx.math.Vector2) -> d
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.Vector3 -> com.badlogic.gdx.math.k:
    float x -> a
    float y -> b
    float z -> c
    com.badlogic.gdx.math.Vector3 X -> d
    com.badlogic.gdx.math.Vector3 Y -> e
    com.badlogic.gdx.math.Vector3 Z -> f
    com.badlogic.gdx.math.Vector3 Zero -> g
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> b
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 scl(float) -> a
    float len2() -> a
    com.badlogic.gdx.math.Vector3 nor() -> b
    float dot(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> e
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> d
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> a
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> b
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.badlogic.gdx.math.WindowedMean -> com.badlogic.gdx.math.l:
    float[] values -> a
    int added_values -> b
    int last_value -> c
    float mean -> d
    boolean dirty -> e
    boolean hasEnoughData() -> a
    void clear() -> b
    void addValue(float) -> a
    float getMean() -> c
com.badlogic.gdx.math.collision.Ray -> com.badlogic.gdx.math.a.a:
    com.badlogic.gdx.math.Vector3 origin -> a
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 tmp -> c
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.badlogic.gdx.net.NetJavaImpl -> com.badlogic.gdx.e.a:
    java.util.concurrent.ExecutorService executorService -> d
    com.badlogic.gdx.utils.ObjectMap connections -> a
    com.badlogic.gdx.utils.ObjectMap listeners -> b
    java.util.concurrent.locks.Lock lock -> c
com.badlogic.gdx.physics.box2d.Body -> com.badlogic.gdx.physics.box2d.Body:
    long addr -> a
    float[] tmp -> g
    com.badlogic.gdx.physics.box2d.World world -> h
    com.badlogic.gdx.utils.Array fixtures -> i
    com.badlogic.gdx.utils.Array joints -> b
    java.lang.Object userData -> j
    com.badlogic.gdx.physics.box2d.Transform transform -> k
    com.badlogic.gdx.math.Vector2 position -> l
    com.badlogic.gdx.math.Vector2 worldCenter -> m
    com.badlogic.gdx.math.Vector2 localCenter -> n
    com.badlogic.gdx.math.Vector2 linearVelocity -> o
    com.badlogic.gdx.physics.box2d.MassData massData -> p
    com.badlogic.gdx.math.Vector2 localPoint -> q
    com.badlogic.gdx.math.Vector2 worldVector -> r
    com.badlogic.gdx.math.Vector2 localPoint2 -> c
    com.badlogic.gdx.math.Vector2 localVector -> d
    com.badlogic.gdx.math.Vector2 linVelWorld -> e
    com.badlogic.gdx.math.Vector2 linVelLoc -> f
    void reset(long) -> a
    com.badlogic.gdx.physics.box2d.Fixture createFixture(com.badlogic.gdx.physics.box2d.FixtureDef) -> a
    long jniCreateFixture(long,long,float,float,float,boolean,short,short,short) -> jniCreateFixture
    void destroyFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
    void jniDestroyFixture(long,long) -> jniDestroyFixture
    com.badlogic.gdx.physics.box2d.Transform getTransform() -> a
    void jniGetTransform(long,float[]) -> jniGetTransform
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    void jniGetPosition(long,float[]) -> jniGetPosition
    com.badlogic.gdx.math.Vector2 getLinearVelocity() -> c
    void jniGetLinearVelocity(long,float[]) -> jniGetLinearVelocity
    com.badlogic.gdx.utils.Array getFixtureList() -> d
    java.lang.Object getUserData() -> e
    void setUserData(java.lang.Object) -> a
com.badlogic.gdx.physics.box2d.BodyDef -> com.badlogic.gdx.physics.box2d.a:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType type -> a
    com.badlogic.gdx.math.Vector2 position -> b
    float angle -> c
    com.badlogic.gdx.math.Vector2 linearVelocity -> d
    float angularVelocity -> e
    float linearDamping -> f
    float angularDamping -> g
    boolean allowSleep -> h
    boolean awake -> i
    boolean fixedRotation -> j
    boolean bullet -> k
    boolean active -> l
    float gravityScale -> m
com.badlogic.gdx.physics.box2d.BodyDef$BodyType -> com.badlogic.gdx.physics.box2d.b:
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType StaticBody -> a
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType KinematicBody -> b
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType DynamicBody -> c
    int value -> d
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] $VALUES -> e
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType[] values() -> values
    com.badlogic.gdx.physics.box2d.BodyDef$BodyType valueOf(java.lang.String) -> valueOf
    int getValue() -> a
com.badlogic.gdx.physics.box2d.ChainShape -> com.badlogic.gdx.physics.box2d.ChainShape:
    boolean isLooped -> a
    float[] verts -> c
    long newChainShape() -> newChainShape
    void createLoop(com.badlogic.gdx.math.Vector2[]) -> a
    void jniCreateLoop(long,float[],int) -> jniCreateLoop
com.badlogic.gdx.physics.box2d.CircleShape -> com.badlogic.gdx.physics.box2d.CircleShape:
    float[] tmp -> a
    com.badlogic.gdx.math.Vector2 position -> c
    long newCircleShape() -> newCircleShape
com.badlogic.gdx.physics.box2d.Contact -> com.badlogic.gdx.physics.box2d.Contact:
    long addr -> a
    com.badlogic.gdx.physics.box2d.World world -> b
    com.badlogic.gdx.physics.box2d.WorldManifold worldManifold -> c
    float[] tmp -> d
    com.badlogic.gdx.physics.box2d.Fixture getFixtureA() -> a
    long jniGetFixtureA(long) -> jniGetFixtureA
    com.badlogic.gdx.physics.box2d.Fixture getFixtureB() -> b
    long jniGetFixtureB(long) -> jniGetFixtureB
com.badlogic.gdx.physics.box2d.ContactFilter -> com.badlogic.gdx.physics.box2d.c:
    boolean shouldCollide(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.ContactImpulse -> com.badlogic.gdx.physics.box2d.ContactImpulse:
    com.badlogic.gdx.physics.box2d.World world -> a
    long addr -> b
    float[] tmp -> c
    float[] normalImpulses -> d
    float[] tangentImpulses -> e
    float[] getNormalImpulses() -> a
    void jniGetNormalImpulses(long,float[]) -> jniGetNormalImpulses
com.badlogic.gdx.physics.box2d.ContactListener -> com.badlogic.gdx.physics.box2d.d:
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
com.badlogic.gdx.physics.box2d.Filter -> com.badlogic.gdx.physics.box2d.e:
    short categoryBits -> a
    short maskBits -> b
    short groupIndex -> c
com.badlogic.gdx.physics.box2d.Fixture -> com.badlogic.gdx.physics.box2d.Fixture:
    com.badlogic.gdx.physics.box2d.Body body -> d
    long addr -> a
    com.badlogic.gdx.physics.box2d.Shape shape -> b
    java.lang.Object userData -> c
    short[] tmp -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
    void reset(com.badlogic.gdx.physics.box2d.Body,long) -> a
    void setSensor(boolean) -> a
    void jniSetSensor(long,boolean) -> jniSetSensor
    boolean isSensor() -> a
    boolean jniIsSensor(long) -> jniIsSensor
    com.badlogic.gdx.physics.box2d.Filter getFilterData() -> b
    void jniGetFilterData(long,short[]) -> jniGetFilterData
    com.badlogic.gdx.physics.box2d.Body getBody() -> c
    void setUserData(java.lang.Object) -> a
    java.lang.Object getUserData() -> d
com.badlogic.gdx.physics.box2d.FixtureDef -> com.badlogic.gdx.physics.box2d.f:
    com.badlogic.gdx.physics.box2d.Shape shape -> a
    float friction -> b
    float restitution -> c
    float density -> d
    boolean isSensor -> e
    com.badlogic.gdx.physics.box2d.Filter filter -> f
com.badlogic.gdx.physics.box2d.Manifold -> com.badlogic.gdx.physics.box2d.g:
    long addr -> a
    com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint[] points -> b
    com.badlogic.gdx.math.Vector2 localNormal -> c
    com.badlogic.gdx.math.Vector2 localPoint -> d
    int[] tmpInt -> e
    float[] tmpFloat -> f
com.badlogic.gdx.physics.box2d.Manifold$ManifoldPoint -> com.badlogic.gdx.physics.box2d.h:
    com.badlogic.gdx.math.Vector2 localPoint -> a
    float normalImpulse -> b
    float tangentImpulse -> c
    int contactID -> d
    com.badlogic.gdx.physics.box2d.Manifold this$0 -> e
    java.lang.String toString() -> toString
com.badlogic.gdx.physics.box2d.MassData -> com.badlogic.gdx.physics.box2d.i:
    com.badlogic.gdx.math.Vector2 center -> a
com.badlogic.gdx.physics.box2d.PolygonShape -> com.badlogic.gdx.physics.box2d.PolygonShape:
    float[] verts -> a
    long newPolygonShape() -> newPolygonShape
    void set(com.badlogic.gdx.math.Vector2[]) -> a
    void jniSet(long,float[],int,int) -> jniSet
    void setAsBox(float,float,com.badlogic.gdx.math.Vector2,float) -> a
    void jniSetAsBox(long,float,float,float,float,float) -> jniSetAsBox
com.badlogic.gdx.physics.box2d.QueryCallback -> com.badlogic.gdx.physics.box2d.j:
    boolean reportFixture(com.badlogic.gdx.physics.box2d.Fixture) -> a
com.badlogic.gdx.physics.box2d.RayCastCallback -> com.badlogic.gdx.physics.box2d.k:
    float reportRayFixture(com.badlogic.gdx.physics.box2d.Fixture,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,float) -> a
com.badlogic.gdx.physics.box2d.Shape -> com.badlogic.gdx.physics.box2d.Shape:
    long addr -> b
    void setRadius(float) -> a
    void jniSetRadius(long,float) -> jniSetRadius
    void dispose() -> a
    void jniDispose(long) -> jniDispose
com.badlogic.gdx.physics.box2d.Transform -> com.badlogic.gdx.physics.box2d.l:
    float[] vals -> a
    com.badlogic.gdx.math.Vector2 position -> b
    com.badlogic.gdx.math.Vector2 mul(com.badlogic.gdx.math.Vector2) -> a
com.badlogic.gdx.physics.box2d.World -> com.badlogic.gdx.physics.box2d.World:
    com.badlogic.gdx.utils.Pool freeBodies -> a
    com.badlogic.gdx.utils.Pool freeFixtures -> b
    long addr -> j
    com.badlogic.gdx.utils.LongMap bodies -> c
    com.badlogic.gdx.utils.LongMap fixtures -> d
    com.badlogic.gdx.utils.LongMap joints -> e
    com.badlogic.gdx.physics.box2d.ContactFilter contactFilter -> f
    com.badlogic.gdx.physics.box2d.ContactListener contactListener -> g
    float[] tmpGravity -> h
    com.badlogic.gdx.math.Vector2 gravity -> i
    com.badlogic.gdx.physics.box2d.QueryCallback queryCallback -> k
    long[] contactAddrs -> l
    com.badlogic.gdx.utils.Array contacts -> m
    com.badlogic.gdx.utils.Array freeContacts -> n
    com.badlogic.gdx.physics.box2d.Contact contact -> o
    com.badlogic.gdx.physics.box2d.Manifold manifold -> p
    com.badlogic.gdx.physics.box2d.ContactImpulse impulse -> q
    com.badlogic.gdx.physics.box2d.RayCastCallback rayCastCallback -> r
    com.badlogic.gdx.math.Vector2 rayPoint -> s
    com.badlogic.gdx.math.Vector2 rayNormal -> t
    long newWorld(float,float,boolean) -> newWorld
    void setContactListener(com.badlogic.gdx.physics.box2d.ContactListener) -> a
    com.badlogic.gdx.physics.box2d.Body createBody(com.badlogic.gdx.physics.box2d.BodyDef) -> a
    long jniCreateBody(long,int,float,float,float,float,float,float,float,float,boolean,boolean,boolean,boolean,boolean,float) -> jniCreateBody
    void step(float,int,int) -> a
    void jniStep(long,float,int,int) -> jniStep
    void setGravity(com.badlogic.gdx.math.Vector2) -> a
    void jniSetGravity(long,float,float) -> jniSetGravity
    void dispose() -> c
    void jniDispose(long) -> jniDispose
    boolean contactFilter(long,long) -> contactFilter
    void beginContact(long) -> beginContact
    void endContact(long) -> endContact
    void preSolve(long,long) -> preSolve
    void postSolve(long,long) -> postSolve
    boolean reportFixture(long) -> reportFixture
    void setVelocityThreshold(float) -> setVelocityThreshold
    float reportRayFixture(long,float,float,float,float,float) -> reportRayFixture
com.badlogic.gdx.physics.box2d.World$1 -> com.badlogic.gdx.physics.box2d.m:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Body newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.World$2 -> com.badlogic.gdx.physics.box2d.n:
    com.badlogic.gdx.physics.box2d.World this$0 -> a
    com.badlogic.gdx.physics.box2d.Fixture newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.physics.box2d.WorldManifold -> com.badlogic.gdx.physics.box2d.o:
    com.badlogic.gdx.math.Vector2 normal -> a
    com.badlogic.gdx.math.Vector2[] points -> b
    float[] separations -> c
com.badlogic.gdx.scenes.scene2d.Action -> com.badlogic.gdx.f.a.a:
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    com.badlogic.gdx.utils.Pool pool -> b
    void restart() -> a
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void reset() -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Actor -> com.badlogic.gdx.f.a.b:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> l
    com.badlogic.gdx.scenes.scene2d.Group parent -> a
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> m
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> n
    com.badlogic.gdx.utils.Array actions -> o
    java.lang.String name -> p
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> q
    boolean visible -> r
    boolean debug -> s
    float x -> b
    float y -> c
    float width -> d
    float height -> e
    float originX -> f
    float originY -> g
    float scaleX -> h
    float scaleY -> i
    float rotation -> j
    com.badlogic.gdx.graphics.Color color -> k
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    boolean remove() -> a
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> a
    void clearActions() -> b
    void clearListeners() -> c
    void clear() -> d
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> e
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> f
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> a
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> g
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> a
    boolean isVisible() -> h
    float getX() -> i
    float getY() -> j
    void setPosition(float,float) -> a
    void setCenterPosition(float,float) -> b
    void moveBy(float,float) -> c
    float getWidth() -> k
    void setWidth(float) -> a
    float getHeight() -> l
    void setHeight(float) -> b
    void positionChanged() -> m
    void sizeChanged() -> n
    void setSize(float,float) -> d
    void setBounds(float,float,float,float) -> a
    float getOriginX() -> o
    float getOriginY() -> p
    float getScaleX() -> q
    float getScaleY() -> r
    float getRotation() -> s
    void setColor(float,float,float,float) -> b
    com.badlogic.gdx.graphics.Color getColor() -> t
    boolean clipBegin(float,float,float,float) -> c
    void clipEnd() -> u
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> a
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> b
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    void setDebug(boolean) -> a
    boolean getDebug() -> v
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.Event -> com.badlogic.gdx.f.a.c:
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    boolean capture -> d
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    void handle() -> a
    void reset() -> b
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> c
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> d
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean getBubbles() -> e
    boolean isHandled() -> f
    boolean isStopped() -> g
    boolean isCancelled() -> h
    void setCapture(boolean) -> a
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> i
com.badlogic.gdx.scenes.scene2d.EventListener -> com.badlogic.gdx.f.a.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> com.badlogic.gdx.f.a.e:
    com.badlogic.gdx.math.Vector2 tmp -> n
    com.badlogic.gdx.utils.SnapshotArray children -> l
    com.badlogic.gdx.math.Matrix3 localTransform -> o
    com.badlogic.gdx.math.Matrix3 worldTransform -> p
    com.badlogic.gdx.math.Matrix4 computedTransform -> q
    com.badlogic.gdx.math.Matrix4 oldTransform -> r
    boolean transform -> m
    com.badlogic.gdx.math.Rectangle cullingArea -> s
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> b
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> c
    com.badlogic.gdx.math.Matrix4 computeTransform() -> w
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> a
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> a
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> d
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void childrenChanged() -> x
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void clearChildren() -> y
    void clear() -> d
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> a
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> z
    void setTransform(boolean) -> b
    boolean isTransform() -> d_
    void setDebug(boolean,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> B
com.badlogic.gdx.scenes.scene2d.InputEvent -> com.badlogic.gdx.f.a.f:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> a
    float stageX -> b
    float stageY -> c
    int pointer -> d
    int button -> e
    int keyCode -> f
    int scrollAmount -> g
    char character -> h
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> i
    void reset() -> b
    void setStageX(float) -> a
    void setStageY(float) -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> j
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> a
    int getPointer() -> k
    void setPointer(int) -> a
    int getButton() -> l
    void setButton(int) -> b
    int getKeyCode() -> m
    void setKeyCode(int) -> c
    char getCharacter() -> n
    void setCharacter(char) -> a
    int getScrollAmount() -> o
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> p
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> a
    java.lang.String toString() -> toString
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> com.badlogic.gdx.f.a.g:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] values() -> values
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.InputListener -> com.badlogic.gdx.f.a.h:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> b
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> a
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> b
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> a
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> com.badlogic.gdx.f.a.i:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> com.badlogic.gdx.f.a.j:
    com.badlogic.gdx.math.Vector2 actorCoords -> b
    boolean debug -> a
    com.badlogic.gdx.utils.viewport.Viewport viewport -> c
    com.badlogic.gdx.graphics.g2d.Batch batch -> d
    boolean ownsBatch -> e
    com.badlogic.gdx.scenes.scene2d.Group root -> f
    com.badlogic.gdx.math.Vector2 stageCoords -> g
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> h
    boolean[] pointerTouched -> i
    int[] pointerScreenX -> j
    int[] pointerScreenY -> k
    int mouseScreenX -> l
    int mouseScreenY -> m
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> n
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> o
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> p
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> q
    boolean debugAll -> r
    boolean debugUnderMouse -> s
    boolean debugParentUnderMouse -> t
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> u
    com.badlogic.gdx.graphics.Color debugColor -> v
    void draw() -> a
    void drawDebug() -> k
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    boolean touchDown(int,int,int,int) -> a
    boolean touchDragged(int,int,int) -> a
    boolean touchUp(int,int,int,int) -> b
    boolean keyDown(int) -> a
    boolean keyUp(int) -> b
    boolean keyTyped(char) -> a
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> a
    void cancelTouchFocus() -> b
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void clear() -> d
    void unfocusAll() -> e
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> b
    com.badlogic.gdx.utils.viewport.Viewport getViewport() -> f
    float getWidth() -> g
    float getHeight() -> h
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> i
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> a
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.Color getDebugColor() -> j
    void dispose() -> c
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> com.badlogic.gdx.f.a.k:
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    int pointer -> d
    int button -> e
    void reset() -> b
com.badlogic.gdx.scenes.scene2d.Touchable -> com.badlogic.gdx.f.a.l:
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable[] values() -> values
    com.badlogic.gdx.scenes.scene2d.Touchable valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.ui.Button -> com.badlogic.gdx.f.a.a.a:
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> C
    boolean isChecked -> n
    boolean isDisabled -> o
    com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup buttonGroup -> p
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> D
    void initialize() -> M
    void setChecked(boolean) -> c
    boolean isPressed() -> a_
    boolean isOver() -> D
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    float getMinWidth() -> G
    float getMinHeight() -> H
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> com.badlogic.gdx.f.a.a.b:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> a
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> com.badlogic.gdx.f.a.a.c:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> f
    float pressedOffsetX -> g
    float pressedOffsetY -> h
    float unpressedOffsetX -> i
    float unpressedOffsetY -> j
com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup -> com.badlogic.gdx.f.a.a.d:
    com.badlogic.gdx.utils.Array checkedButtons -> a
    int minCheckCount -> b
    int maxCheckCount -> c
    boolean uncheckLast -> d
    com.badlogic.gdx.scenes.scene2d.ui.Button lastChecked -> e
    boolean canCheck(com.badlogic.gdx.scenes.scene2d.ui.Button,boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.Cell -> com.badlogic.gdx.f.a.a.e:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    java.lang.Float fillX -> o
    java.lang.Float fillY -> p
    java.lang.Integer align -> q
    java.lang.Integer expandX -> r
    java.lang.Integer expandY -> s
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformX -> u
    java.lang.Boolean uniformY -> v
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    float actorX -> x
    float actorY -> y
    float actorWidth -> z
    float actorHeight -> A
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> J
    boolean endRow -> B
    int column -> C
    int row -> D
    int cellAboveIndex -> E
    float computedPadTop -> F
    float computedPadLeft -> G
    float computedPadBottom -> H
    float computedPadRight -> I
    void setLayout(com.badlogic.gdx.scenes.scene2d.ui.Table) -> a
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> a
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(com.badlogic.gdx.scenes.scene2d.ui.Value,com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell size(float,float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell pad(float) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> c
    void setActorBounds(float,float,float,float) -> a
    void setActorY(float) -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell row() -> d
    void clear() -> e
    void reset() -> b
    void defaults() -> f
com.badlogic.gdx.scenes.scene2d.ui.Label -> com.badlogic.gdx.f.a.a.f:
    com.badlogic.gdx.graphics.Color tempColor -> l
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> m
    com.badlogic.gdx.graphics.g2d.BitmapFont$TextBounds bounds -> n
    com.badlogic.gdx.utils.StringBuilder text -> o
    com.badlogic.gdx.utils.StringBuilder tempText -> p
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> q
    int labelAlign -> r
    com.badlogic.gdx.graphics.g2d.BitmapFont$HAlignment lineAlign -> s
    boolean wrap -> t
    float lastPrefHeight -> u
    boolean sizeInvalid -> v
    float fontScaleX -> w
    float fontScaleY -> x
    boolean ellipse -> y
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> w
    void invalidate() -> x
    void scaleAndComputeSize() -> D
    void computeSize() -> I
    void layout() -> y
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    void setWrap(boolean) -> b
    void setAlignment(int) -> a
    void setAlignment(int,int) -> a
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> com.badlogic.gdx.f.a.a.g:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
com.badlogic.gdx.scenes.scene2d.ui.Skin -> com.badlogic.gdx.f.a.a.h:
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    void load(com.badlogic.gdx.files.FileHandle) -> a
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> a
    void add(java.lang.String,java.lang.Object) -> a
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> a
    java.lang.Object get(java.lang.Class) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> a
    java.lang.Object optional(java.lang.String,java.lang.Class) -> b
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> b
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> a
    void dispose() -> c
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> com.badlogic.gdx.f.a.a.i:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> com.badlogic.gdx.f.a.a.j:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> com.badlogic.gdx.f.a.a.k:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> com.badlogic.gdx.f.a.a.l:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> com.badlogic.gdx.f.a.a.m:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> com.badlogic.gdx.f.a.a.n:
com.badlogic.gdx.scenes.scene2d.ui.Table -> com.badlogic.gdx.f.a.a.o:
    com.badlogic.gdx.graphics.Color debugTableColor -> q
    com.badlogic.gdx.graphics.Color debugCellColor -> r
    com.badlogic.gdx.graphics.Color debugActorColor -> s
    com.badlogic.gdx.utils.Pool cellPool -> t
    float[] columnWeightedWidth -> n
    float[] rowWeightedHeight -> o
    int columns -> p
    int rows -> C
    com.badlogic.gdx.utils.Array cells -> D
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> E
    com.badlogic.gdx.utils.Array columnDefaults -> F
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> G
    boolean sizeInvalid -> H
    float[] columnMinWidth -> I
    float[] rowMinHeight -> J
    float[] columnPrefWidth -> K
    float[] rowPrefHeight -> L
    float tableMinWidth -> M
    float tableMinHeight -> N
    float tablePrefWidth -> O
    float tablePrefHeight -> P
    float[] columnWidth -> Q
    float[] rowHeight -> R
    float[] expandWidth -> S
    float[] expandHeight -> T
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> u
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> v
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> x
    int align -> y
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> z
    com.badlogic.gdx.utils.Array debugRects -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> U
    boolean clip -> V
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> W
    boolean round -> B
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> D
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> a
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> a
    void invalidate() -> I
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> d
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void clearChildren() -> y
    com.badlogic.gdx.scenes.scene2d.ui.Cell row() -> J
    void endRow() -> M
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    float getMinWidth() -> G
    float getMinHeight() -> H
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(com.badlogic.gdx.scenes.scene2d.ui.Value) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table pad(float,float,float,float) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table padTop(float) -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table padLeft(float) -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table padBottom(float) -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(float) -> f
    void setDebug(boolean) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> K
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> a
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> a
    float[] ensureSize(float[],int) -> a
    void layout() -> L
    void computeSize() -> N
    void layout(float,float,float,float) -> e
    void clearDebugRects() -> O
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> a
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> a
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> b
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> e
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> B
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> com.badlogic.gdx.f.a.a.p:
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> com.badlogic.gdx.f.a.a.q:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> b
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] values() -> values
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> com.badlogic.gdx.f.a.a.r:
    com.badlogic.gdx.utils.Pool pool -> g
    com.badlogic.gdx.graphics.Color color -> h
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> com.badlogic.gdx.f.a.a.s:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> C
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> D
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> com.badlogic.gdx.f.a.a.t:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> k
    com.badlogic.gdx.graphics.Color fontColor -> l
    com.badlogic.gdx.graphics.Color downFontColor -> m
    com.badlogic.gdx.graphics.Color overFontColor -> n
    com.badlogic.gdx.graphics.Color checkedFontColor -> o
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> p
    com.badlogic.gdx.graphics.Color disabledFontColor -> q
com.badlogic.gdx.scenes.scene2d.ui.Value -> com.badlogic.gdx.f.a.a.u:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> com.badlogic.gdx.f.a.a.v:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> com.badlogic.gdx.f.a.a.w:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> com.badlogic.gdx.f.a.a.x:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> com.badlogic.gdx.f.a.a.y:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> com.badlogic.gdx.f.a.a.z:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> com.badlogic.gdx.f.a.a.aa:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> com.badlogic.gdx.f.a.a.ab:
    float value -> h
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Widget -> com.badlogic.gdx.f.a.a.ac:
    boolean needsLayout -> l
    boolean fillParent -> m
    boolean layoutEnabled -> n
    float getMinWidth() -> G
    float getMinHeight() -> H
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    float getMaxWidth() -> b_
    float getMaxHeight() -> A
    void validate() -> c_
    void invalidate() -> x
    void invalidateHierarchy() -> C
    void sizeChanged() -> n
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
    void layout() -> y
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> com.badlogic.gdx.f.a.a.ad:
    boolean needsLayout -> n
    boolean fillParent -> o
    boolean layoutEnabled -> p
    float getMinWidth() -> G
    float getMinHeight() -> H
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    float getMaxWidth() -> b_
    float getMaxHeight() -> A
    void validate() -> c_
    void invalidate() -> I
    void invalidateHierarchy() -> C
    void childrenChanged() -> x
    void sizeChanged() -> n
    void setFillParent(boolean) -> d
    void layout() -> L
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> a
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> com.badlogic.gdx.f.a.b.a:
    float leftWidth -> a
    float rightWidth -> b
    float topHeight -> c
    float bottomHeight -> d
    float minWidth -> e
    float minHeight -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    void setLeftWidth(float) -> a
    float getRightWidth() -> b
    void setRightWidth(float) -> b
    float getTopHeight() -> c
    void setTopHeight(float) -> c
    float getBottomHeight() -> d
    void setBottomHeight(float) -> d
    float getMinWidth() -> e
    void setMinWidth(float) -> e
    float getMinHeight() -> f
    void setMinHeight(float) -> f
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener -> com.badlogic.gdx.f.a.b.b:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void changed(com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent,com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> com.badlogic.gdx.f.a.b.c:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> com.badlogic.gdx.f.a.b.d:
    float visualPressedDuration -> b
    float tapSquareSize -> a
    float touchDownX -> c
    float touchDownY -> d
    int pressedPointer -> e
    int pressedButton -> f
    int button -> g
    boolean pressed -> h
    boolean over -> i
    boolean cancelled -> j
    float visualPressedTime -> k
    long tapCountInterval -> l
    int tapCount -> m
    long lastTapTime -> n
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> a
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> a
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> b
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> a
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> a
    boolean inTapSquare(float,float) -> a
    void invalidateTapSquare() -> a
    boolean isVisualPressed() -> b
    boolean isOver() -> c
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> com.badlogic.gdx.f.a.b.e:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    float getLeftWidth() -> a
    float getRightWidth() -> b
    float getTopHeight() -> c
    float getBottomHeight() -> d
    float getMinWidth() -> e
    float getMinHeight() -> f
com.badlogic.gdx.scenes.scene2d.utils.Layout -> com.badlogic.gdx.f.a.b.f:
    void invalidateHierarchy() -> C
    void validate() -> c_
    float getMinWidth() -> G
    float getMinHeight() -> H
    float getPrefWidth() -> E
    float getPrefHeight() -> F
    float getMaxWidth() -> b_
    float getMaxHeight() -> A
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> com.badlogic.gdx.f.a.b.g:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> a
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> g
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> com.badlogic.gdx.f.a.b.h:
    com.badlogic.gdx.utils.Array scissors -> c
    com.badlogic.gdx.math.Vector3 tmp -> a
    com.badlogic.gdx.math.Rectangle viewport -> b
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.math.Rectangle popScissors() -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> com.badlogic.gdx.f.a.b.i:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> a
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> a
    com.badlogic.gdx.graphics.g2d.Sprite getSprite() -> g
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> com.badlogic.gdx.f.a.b.j:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> g
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> com.badlogic.gdx.f.a.b.k:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> a
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> com.badlogic.gdx.f.a.b.l:
com.badlogic.gdx.utils.Array -> com.badlogic.gdx.utils.a:
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> d
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> a
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> a
    void addAll(java.lang.Object[],int,int) -> a
    java.lang.Object get(int) -> a
    void set(int,java.lang.Object) -> a
    boolean contains(java.lang.Object,boolean) -> a
    int indexOf(java.lang.Object,boolean) -> b
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    java.lang.Object pop() -> a
    java.lang.Object peek() -> b
    java.lang.Object first() -> c
    void clear() -> d
    java.lang.Object[] ensureCapacity(int) -> c
    java.lang.Object[] resize(int) -> d
    void sort(java.util.Comparator) -> a
    java.util.Iterator iterator() -> iterator
    java.lang.Object[] toArray(java.lang.Class) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.Array$ArrayIterable -> com.badlogic.gdx.utils.b:
    com.badlogic.gdx.utils.Array array -> a
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> c
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> d
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.Array$ArrayIterator -> com.badlogic.gdx.utils.c:
    com.badlogic.gdx.utils.Array array -> c
    boolean allowRemove -> d
    int index -> a
    boolean valid -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.ArrayMap -> com.badlogic.gdx.utils.d:
    java.lang.Object[] keys -> a
    java.lang.Object[] values -> b
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    void put(java.lang.Object,java.lang.Object) -> a
    int indexOfKey(java.lang.Object) -> a
    void removeIndex(int) -> a
    void clear() -> a
    void resize(int) -> b
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> b
com.badlogic.gdx.utils.ArrayMap$Entries -> com.badlogic.gdx.utils.e:
    com.badlogic.gdx.utils.ArrayMap map -> d
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    int index -> b
    boolean valid -> c
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
com.badlogic.gdx.utils.Base64Coder -> com.badlogic.gdx.utils.f:
    char[] map1 -> a
    byte[] map2 -> b
    char[] encode(byte[]) -> a
    char[] encode(byte[],int,int) -> a
    byte[] decode(java.lang.String) -> a
    byte[] decode(char[]) -> a
    byte[] decode(char[],int,int) -> a
com.badlogic.gdx.utils.BaseJsonReader -> com.badlogic.gdx.utils.g:
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    java.nio.FloatBuffer newFloatBuffer(int) -> a
    java.nio.ByteBuffer newByteBuffer(int) -> b
    java.nio.IntBuffer newIntBuffer(int) -> c
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> d
    void freeMemory(java.nio.ByteBuffer) -> freeMemory
    java.nio.ByteBuffer newDisposableByteBuffer(int) -> newDisposableByteBuffer
    void copyJni(float[],java.nio.Buffer,int,int) -> copyJni
com.badlogic.gdx.utils.DelayedRemovalArray -> com.badlogic.gdx.utils.h:
    int iterating -> d
    com.badlogic.gdx.utils.IntArray remove -> e
    void begin() -> e
    void end() -> f
    void remove(int) -> e
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    void set(int,java.lang.Object) -> a
    java.lang.Object pop() -> a
    void clear() -> d
    void sort(java.util.Comparator) -> a
com.badlogic.gdx.utils.Disposable -> com.badlogic.gdx.utils.i:
    void dispose() -> c
com.badlogic.gdx.utils.FloatArray -> com.badlogic.gdx.utils.j:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    float get(int) -> a
    void clear() -> a
    float[] resize(int) -> b
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.GdxNativesLoader -> com.badlogic.gdx.utils.k:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> com.badlogic.gdx.utils.l:
com.badlogic.gdx.utils.I18NBundle -> com.badlogic.gdx.utils.m:
    boolean simpleFormatter -> a
    com.badlogic.gdx.utils.I18NBundle parent -> b
    java.util.Locale locale -> c
    com.badlogic.gdx.utils.ObjectMap properties -> d
    com.badlogic.gdx.utils.TextFormatter formatter -> e
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> a
    com.badlogic.gdx.utils.I18NBundle createBundleImpl(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> b
    java.util.List getCandidateLocales(java.util.Locale) -> a
    java.util.Locale getFallbackLocale(java.util.Locale) -> b
    com.badlogic.gdx.utils.I18NBundle loadBundleChain(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.List,int,com.badlogic.gdx.utils.I18NBundle) -> a
    com.badlogic.gdx.utils.I18NBundle loadBundle(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.Locale) -> a
    void load(java.io.Reader) -> a
    com.badlogic.gdx.files.FileHandle toFileHandle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> b
    java.util.Locale getLocale() -> a
    void setLocale(java.util.Locale) -> c
com.badlogic.gdx.utils.IntArray -> com.badlogic.gdx.utils.n:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    int get(int) -> b
    void insert(int,int) -> a
    int removeIndex(int) -> c
    int pop() -> a
    void clear() -> b
    int[] ensureCapacity(int) -> d
    int[] resize(int) -> e
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.Json -> com.badlogic.gdx.utils.o:
    java.lang.String typeName -> a
    boolean usePrototypes -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> c
    com.badlogic.gdx.utils.ObjectMap typeToFields -> d
    com.badlogic.gdx.utils.ObjectMap tagToClass -> e
    com.badlogic.gdx.utils.ObjectMap classToTag -> f
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> g
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> h
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> i
    boolean ignoreUnknownFields -> j
    void setTypeName(java.lang.String) -> a
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> a
    void setUsePrototypes(boolean) -> a
    com.badlogic.gdx.utils.ObjectMap cacheFields(java.lang.Class) -> b
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> a
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> a
    java.lang.Object newInstance(java.lang.Class) -> a
com.badlogic.gdx.utils.Json$FieldMetadata -> com.badlogic.gdx.utils.p:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> com.badlogic.gdx.utils.q:
com.badlogic.gdx.utils.Json$Serializable -> com.badlogic.gdx.utils.r:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> com.badlogic.gdx.utils.s:
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.utils.JsonReader -> com.badlogic.gdx.utils.t:
    byte[] _json_actions -> a
    short[] _json_key_offsets -> b
    char[] _json_trans_keys -> c
    byte[] _json_single_lengths -> d
    byte[] _json_range_lengths -> e
    short[] _json_index_offsets -> f
    byte[] _json_indicies -> g
    byte[] _json_trans_targs -> h
    byte[] _json_trans_actions -> i
    byte[] _json_eof_actions -> j
    com.badlogic.gdx.utils.Array elements -> k
    com.badlogic.gdx.utils.Array lastChild -> l
    com.badlogic.gdx.utils.JsonValue root -> m
    com.badlogic.gdx.utils.JsonValue current -> n
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> a
    byte[] init__json_actions_0() -> b
    short[] init__json_key_offsets_0() -> c
    char[] init__json_trans_keys_0() -> d
    byte[] init__json_single_lengths_0() -> e
    byte[] init__json_range_lengths_0() -> f
    short[] init__json_index_offsets_0() -> g
    byte[] init__json_indicies_0() -> h
    byte[] init__json_trans_targs_0() -> i
    byte[] init__json_trans_actions_0() -> j
    byte[] init__json_eof_actions_0() -> k
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void startObject(java.lang.String) -> a
    void startArray(java.lang.String) -> b
    void pop() -> a
    void string(java.lang.String,java.lang.String) -> a
    void number(java.lang.String,double) -> a
    void number(java.lang.String,long) -> a
    void bool(java.lang.String,boolean) -> a
    java.lang.String unescape(java.lang.String) -> c
com.badlogic.gdx.utils.JsonValue -> com.badlogic.gdx.utils.u:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> f
    java.lang.String stringValue -> g
    double doubleValue -> h
    long longValue -> i
    java.lang.String name -> a
    com.badlogic.gdx.utils.JsonValue child -> b
    com.badlogic.gdx.utils.JsonValue next -> c
    com.badlogic.gdx.utils.JsonValue prev -> d
    int size -> e
    com.badlogic.gdx.utils.JsonValue get(int) -> a
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> a
    com.badlogic.gdx.utils.JsonValue require(java.lang.String) -> b
    com.badlogic.gdx.utils.JsonValue remove(java.lang.String) -> c
    java.lang.String asString() -> a
    float asFloat() -> b
    double asDouble() -> c
    long asLong() -> d
    int asInt() -> e
    boolean asBoolean() -> f
    byte asByte() -> g
    short asShort() -> h
    float[] asFloatArray() -> i
    short[] asShortArray() -> j
    java.lang.String getString(java.lang.String,java.lang.String) -> a
    float getFloat(java.lang.String,float) -> a
    java.lang.String getString(java.lang.String) -> d
    float getFloat(java.lang.String) -> e
    float getFloat(int) -> b
    short getShort(int) -> c
    boolean isArray() -> k
    boolean isObject() -> l
    boolean isString() -> m
    boolean isNumber() -> n
    boolean isDouble() -> o
    boolean isLong() -> p
    boolean isBoolean() -> q
    boolean isNull() -> r
    boolean isValue() -> s
    java.lang.String name() -> t
    void setName(java.lang.String) -> f
    com.badlogic.gdx.utils.JsonValue child() -> u
    com.badlogic.gdx.utils.JsonValue next() -> v
    void set(java.lang.String) -> g
    void set(double) -> a
    void set(long) -> a
    void set(boolean) -> a
    java.lang.String toString() -> toString
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> a
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> a
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> a
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> b
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> a
    com.badlogic.gdx.utils.JsonValue$JsonIterator iterator() -> w
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.JsonValue$1 -> com.badlogic.gdx.utils.v:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> com.badlogic.gdx.utils.w:
    com.badlogic.gdx.utils.JsonValue entry -> a
    com.badlogic.gdx.utils.JsonValue current -> b
    com.badlogic.gdx.utils.JsonValue this$0 -> c
    boolean hasNext() -> hasNext
    com.badlogic.gdx.utils.JsonValue next() -> a
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> com.badlogic.gdx.utils.x:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> com.badlogic.gdx.utils.y:
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType[] values() -> values
    com.badlogic.gdx.utils.JsonValue$ValueType valueOf(java.lang.String) -> valueOf
com.badlogic.gdx.utils.JsonWriter -> com.badlogic.gdx.utils.z:
    java.io.Writer writer -> a
    com.badlogic.gdx.utils.Array stack -> b
    com.badlogic.gdx.utils.JsonWriter$JsonObject current -> c
    boolean named -> d
    com.badlogic.gdx.utils.JsonWriter pop() -> a
    void write(char[],int,int) -> write
    void flush() -> flush
    void close() -> close
com.badlogic.gdx.utils.JsonWriter$1 -> com.badlogic.gdx.utils.aa:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$JsonObject -> com.badlogic.gdx.utils.ab:
    boolean array -> a
    com.badlogic.gdx.utils.JsonWriter this$0 -> b
    void close() -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> com.badlogic.gdx.utils.ac:
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    java.util.regex.Pattern minimalNamePattern -> e
    java.util.regex.Pattern minimalValuePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    com.badlogic.gdx.utils.JsonWriter$OutputType[] values() -> values
    com.badlogic.gdx.utils.JsonWriter$OutputType valueOf(java.lang.String) -> valueOf
    java.lang.String quoteValue(java.lang.Object) -> a
    java.lang.String quoteName(java.lang.String) -> a
com.badlogic.gdx.utils.Logger -> com.badlogic.gdx.utils.ad:
    java.lang.String tag -> a
    int level -> b
    void debug(java.lang.String) -> a
    void info(java.lang.String) -> b
    void error(java.lang.String,java.lang.Throwable) -> a
    int getLevel() -> a
com.badlogic.gdx.utils.LongMap -> com.badlogic.gdx.utils.ae:
    int size -> a
    long[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    java.lang.Object zeroValue -> f
    boolean hasZeroValue -> g
    float loadFactor -> h
    int hashShift -> i
    int mask -> j
    int threshold -> k
    int stashCapacity -> l
    int pushIterations -> m
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> n
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> o
    java.lang.Object put(long,java.lang.Object) -> a
    void putResize(long,java.lang.Object) -> b
    void push(long,java.lang.Object,int,long,int,long,int,long) -> a
    void putStash(long,java.lang.Object) -> c
    java.lang.Object get(long) -> a
    java.lang.Object getStash(long,java.lang.Object) -> d
    java.lang.Object remove(long) -> b
    java.lang.Object removeStash(long) -> c
    void removeStashIndex(int) -> a
    void resize(int) -> b
    int hash2(long) -> d
    int hash3(long) -> e
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
com.badlogic.gdx.utils.LongMap$Entries -> com.badlogic.gdx.utils.af:
    com.badlogic.gdx.utils.LongMap$Entry entry -> f
    com.badlogic.gdx.utils.LongMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.LongMap$Entry -> com.badlogic.gdx.utils.ag:
    long key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.LongMap$MapIterator -> com.badlogic.gdx.utils.ah:
    boolean hasNext -> a
    com.badlogic.gdx.utils.LongMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.NumberUtils -> com.badlogic.gdx.utils.ai:
    boolean intToFloatColorMask -> a
    int floatToIntBits(float) -> a
    int floatToRawIntBits(float) -> b
    int floatToIntColor(float) -> c
    float intToFloatColor(int) -> a
com.badlogic.gdx.utils.ObjectIntMap -> com.badlogic.gdx.utils.aj:
    int size -> a
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> f
    int hashShift -> g
    int mask -> h
    int threshold -> i
    int stashCapacity -> j
    int pushIterations -> k
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> l
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> m
    void put(java.lang.Object,int) -> a
    void putResize(java.lang.Object,int) -> c
    void push(java.lang.Object,int,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,int) -> d
    int get(java.lang.Object,int) -> b
    int getStash(java.lang.Object,int) -> e
    void removeStashIndex(int) -> a
    void clear() -> a
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> b
com.badlogic.gdx.utils.ObjectIntMap$Entries -> com.badlogic.gdx.utils.ak:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectIntMap$Entry -> com.badlogic.gdx.utils.al:
    java.lang.Object key -> a
    int value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> com.badlogic.gdx.utils.am:
    boolean hasNext -> a
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectMap -> com.badlogic.gdx.utils.an:
    int size -> a
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int capacity -> d
    int stashSize -> e
    float loadFactor -> f
    int hashShift -> g
    int mask -> h
    int threshold -> i
    int stashCapacity -> j
    int pushIterations -> k
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> l
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> m
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> n
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> o
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> p
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> q
    java.lang.Object put(java.lang.Object,java.lang.Object) -> a
    java.lang.Object put_internal(java.lang.Object,java.lang.Object) -> b
    void putResize(java.lang.Object,java.lang.Object) -> c
    void push(java.lang.Object,java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void putStash(java.lang.Object,java.lang.Object) -> d
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Object getStash(java.lang.Object) -> e
    java.lang.Object remove(java.lang.Object) -> b
    java.lang.Object removeStash(java.lang.Object) -> c
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean containsKey(java.lang.Object) -> d
    boolean containsKeyStash(java.lang.Object) -> f
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String,boolean) -> a
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Values values() -> c
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> d
com.badlogic.gdx.utils.ObjectMap$Entries -> com.badlogic.gdx.utils.ao:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> a
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
    boolean hasNext() -> hasNext
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
    java.lang.Object next() -> next
com.badlogic.gdx.utils.ObjectMap$Entry -> com.badlogic.gdx.utils.ap:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.ObjectMap$Keys -> com.badlogic.gdx.utils.aq:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    com.badlogic.gdx.utils.Array toArray() -> a
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> a
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$MapIterator -> com.badlogic.gdx.utils.ar:
    boolean hasNext -> b
    com.badlogic.gdx.utils.ObjectMap map -> c
    int nextIndex -> d
    int currentIndex -> e
    boolean valid -> f
    void reset() -> b
    void findNextIndex() -> c
    void remove() -> remove
com.badlogic.gdx.utils.ObjectMap$Values -> com.badlogic.gdx.utils.as:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
    void remove() -> remove
    void reset() -> b
com.badlogic.gdx.utils.ObjectSet -> com.badlogic.gdx.utils.at:
    int size -> a
    java.lang.Object[] keyTable -> b
    int capacity -> c
    int stashSize -> d
    float loadFactor -> e
    int hashShift -> f
    int mask -> g
    int threshold -> h
    int stashCapacity -> i
    int pushIterations -> j
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> k
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> l
    boolean add(java.lang.Object) -> a
    void addResize(java.lang.Object) -> c
    void push(java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> a
    void addStash(java.lang.Object) -> d
    void removeStashIndex(int) -> a
    void clear() -> a
    boolean contains(java.lang.Object) -> b
    boolean containsKeyStash(java.lang.Object) -> e
    void resize(int) -> b
    int hash2(int) -> c
    int hash3(int) -> d
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String) -> a
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> b
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> com.badlogic.gdx.utils.au:
    boolean hasNext -> a
    com.badlogic.gdx.utils.ObjectSet set -> b
    int nextIndex -> c
    int currentIndex -> d
    boolean valid -> e
    void reset() -> a
    void findNextIndex() -> b
    void remove() -> remove
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.util.Iterator iterator() -> iterator
com.badlogic.gdx.utils.Pool -> com.badlogic.gdx.utils.av:
    int max -> b
    int peak -> c
    com.badlogic.gdx.utils.Array freeObjects -> a
    java.lang.Object newObject() -> b
    java.lang.Object obtain() -> c
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array) -> a
com.badlogic.gdx.utils.Pool$Poolable -> com.badlogic.gdx.utils.aw:
    void reset() -> b
com.badlogic.gdx.utils.Pools -> com.badlogic.gdx.utils.ax:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> a
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> a
    java.lang.Object obtain(java.lang.Class) -> b
    void free(java.lang.Object) -> a
com.badlogic.gdx.utils.PropertiesUtils -> com.badlogic.gdx.utils.ay:
    void load(com.badlogic.gdx.utils.ObjectMap,java.io.Reader) -> a
com.badlogic.gdx.utils.ReflectionPool -> com.badlogic.gdx.utils.az:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> a
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> a
    java.lang.Object newObject() -> b
com.badlogic.gdx.utils.Scaling -> com.badlogic.gdx.utils.ba:
    com.badlogic.gdx.utils.Scaling fit -> a
    com.badlogic.gdx.utils.Scaling fill -> b
    com.badlogic.gdx.utils.Scaling fillX -> c
    com.badlogic.gdx.utils.Scaling fillY -> d
    com.badlogic.gdx.utils.Scaling stretch -> e
    com.badlogic.gdx.utils.Scaling stretchX -> f
    com.badlogic.gdx.utils.Scaling stretchY -> g
    com.badlogic.gdx.utils.Scaling none -> h
    com.badlogic.gdx.math.Vector2 temp -> i
    com.badlogic.gdx.utils.Scaling[] $VALUES -> j
    com.badlogic.gdx.utils.Scaling[] values() -> values
    com.badlogic.gdx.utils.Scaling valueOf(java.lang.String) -> valueOf
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> com.badlogic.gdx.utils.bb:
    int[] $SwitchMap$com$badlogic$gdx$utils$Scaling -> a
com.badlogic.gdx.utils.SerializationException -> com.badlogic.gdx.utils.bc:
    java.lang.StringBuffer trace -> a
    java.lang.String getMessage() -> getMessage
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoader -> com.badlogic.gdx.utils.bd:
    boolean isWindows -> a
    boolean isLinux -> b
    boolean isMac -> c
    boolean isIos -> d
    boolean isAndroid -> e
    boolean isARM -> f
    boolean is64Bit -> g
    java.lang.String abi -> h
    java.util.HashSet loadedLibraries -> i
    java.lang.String nativesJar -> j
    java.lang.String crc(java.io.InputStream) -> a
    java.lang.String mapLibraryName(java.lang.String) -> a
    void load(java.lang.String) -> b
    java.io.InputStream readFile(java.lang.String) -> c
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> a
    void loadFile(java.lang.String) -> d
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> b
com.badlogic.gdx.utils.ShortArray -> com.badlogic.gdx.utils.be:
    short[] items -> a
    int size -> b
    boolean ordered -> c
    void add(short) -> a
    short removeIndex(int) -> a
    void clear() -> a
    short[] ensureCapacity(int) -> b
    short[] resize(int) -> c
    short[] toArray() -> b
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.badlogic.gdx.utils.SnapshotArray -> com.badlogic.gdx.utils.bf:
    java.lang.Object[] snapshot -> d
    java.lang.Object[] recycled -> e
    int snapshots -> f
    java.lang.Object[] begin() -> e
    void end() -> f
    void modified() -> g
    void set(int,java.lang.Object) -> a
    boolean removeValue(java.lang.Object,boolean) -> c
    java.lang.Object removeIndex(int) -> b
    java.lang.Object pop() -> a
    void clear() -> d
    void sort(java.util.Comparator) -> a
com.badlogic.gdx.utils.Sort -> com.badlogic.gdx.utils.bg:
    com.badlogic.gdx.utils.Sort instance -> a
    com.badlogic.gdx.utils.TimSort timSort -> b
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> a
    com.badlogic.gdx.utils.Sort instance() -> a
com.badlogic.gdx.utils.StreamUtils -> com.badlogic.gdx.utils.bh:
    byte[] EMPTY_BYTES -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream,int) -> a
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> a
    void closeQuietly(java.io.Closeable) -> a
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> com.badlogic.gdx.utils.bi:
    byte[] toByteArray() -> toByteArray
com.badlogic.gdx.utils.StringBuilder -> com.badlogic.gdx.utils.bj:
    char[] chars -> a
    int length -> b
    char[] digits -> c
    int numChars(int,int) -> a
    int numChars(long,int) -> a
    void enlargeBuffer(int) -> c
    void appendNull() -> a
    void append0(char[]) -> a
    void append0(char[],int,int) -> a
    void append0(char) -> a
    void append0(java.lang.String) -> a
    void append0(java.lang.CharSequence,int,int) -> a
    char charAt(int) -> charAt
    int length() -> length
    void setLength(int) -> a
    java.lang.String substring(int,int) -> b
    java.lang.String toString() -> toString
    java.lang.CharSequence subSequence(int,int) -> subSequence
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> a
    com.badlogic.gdx.utils.StringBuilder append(char) -> b
    com.badlogic.gdx.utils.StringBuilder append(int) -> b
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> c
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(long) -> a
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> a
    com.badlogic.gdx.utils.StringBuilder append(float) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> b
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> b
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> b
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder,int,int) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
com.badlogic.gdx.utils.TextFormatter -> com.badlogic.gdx.utils.bk:
    java.text.MessageFormat messageFormat -> a
    com.badlogic.gdx.utils.StringBuilder buffer -> b
com.badlogic.gdx.utils.TimSort -> com.badlogic.gdx.utils.bl:
    java.lang.Object[] a -> a
    java.util.Comparator c -> b
    int minGallop -> c
    java.lang.Object[] tmp -> d
    int tmpCount -> e
    int stackSize -> f
    int[] runBase -> g
    int[] runLen -> h
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> a
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> a
    void reverseRange(java.lang.Object[],int,int) -> a
    int minRunLength(int) -> a
    void pushRun(int,int) -> a
    void mergeCollapse() -> a
    void mergeForceCollapse() -> b
    void mergeAt(int) -> b
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> b
    void mergeLo(int,int,int,int) -> a
    void mergeHi(int,int,int,int) -> b
    java.lang.Object[] ensureCapacity(int) -> c
    void rangeCheck(int,int,int) -> a
com.badlogic.gdx.utils.TimeUtils -> com.badlogic.gdx.utils.bm:
    long nanoTime() -> a
com.badlogic.gdx.utils.UBJsonReader -> com.badlogic.gdx.utils.bn:
    boolean oldFormat -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.InputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream,byte) -> a
    com.badlogic.gdx.utils.JsonValue parseArray(java.io.DataInputStream) -> b
    com.badlogic.gdx.utils.JsonValue parseObject(java.io.DataInputStream) -> c
    com.badlogic.gdx.utils.JsonValue parseData(java.io.DataInputStream,byte) -> b
    java.lang.String parseString(java.io.DataInputStream,byte) -> c
    java.lang.String parseString(java.io.DataInputStream,boolean,byte) -> a
    long parseSize(java.io.DataInputStream,boolean,long) -> a
    long parseSize(java.io.DataInputStream,byte,boolean,long) -> a
    short readUChar(java.io.DataInputStream) -> d
    int readUShort(java.io.DataInputStream) -> e
    long readUInt(java.io.DataInputStream) -> f
    java.lang.String readString(java.io.DataInputStream,long) -> a
com.badlogic.gdx.utils.async.AsyncExecutor -> com.badlogic.gdx.utils.a.a:
    java.util.concurrent.ExecutorService executor -> a
    com.badlogic.gdx.utils.async.AsyncResult submit(com.badlogic.gdx.utils.async.AsyncTask) -> a
    void dispose() -> c
com.badlogic.gdx.utils.async.AsyncExecutor$1 -> com.badlogic.gdx.utils.a.b:
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
com.badlogic.gdx.utils.async.AsyncExecutor$2 -> com.badlogic.gdx.utils.a.c:
    com.badlogic.gdx.utils.async.AsyncTask val$task -> a
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> b
    java.lang.Object call() -> call
com.badlogic.gdx.utils.async.AsyncResult -> com.badlogic.gdx.utils.a.d:
    java.util.concurrent.Future future -> a
    boolean isDone() -> a
    java.lang.Object get() -> b
com.badlogic.gdx.utils.async.AsyncTask -> com.badlogic.gdx.utils.a.e:
    java.lang.Object call() -> d
com.badlogic.gdx.utils.async.ThreadUtils -> com.badlogic.gdx.utils.a.f:
    void yield() -> a
com.badlogic.gdx.utils.reflect.ArrayReflection -> com.badlogic.gdx.utils.b.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> a
com.badlogic.gdx.utils.reflect.ClassReflection -> com.badlogic.gdx.utils.b.b:
    java.lang.Class forName(java.lang.String) -> a
    java.lang.String getSimpleName(java.lang.Class) -> a
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> a
    boolean isMemberClass(java.lang.Class) -> b
    boolean isStaticClass(java.lang.Class) -> c
    java.lang.Object newInstance(java.lang.Class) -> d
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> a
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> b
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> e
com.badlogic.gdx.utils.reflect.Constructor -> com.badlogic.gdx.utils.b.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    void setAccessible(boolean) -> a
    java.lang.Object newInstance(java.lang.Object[]) -> a
com.badlogic.gdx.utils.reflect.Field -> com.badlogic.gdx.utils.b.d:
    java.lang.reflect.Field field -> a
    java.lang.String getName() -> a
    java.lang.Class getType() -> b
    boolean isAccessible() -> c
    void setAccessible(boolean) -> a
    boolean isStatic() -> d
    boolean isTransient() -> e
    boolean isSynthetic() -> f
    java.lang.Class getElementType(int) -> a
    void set(java.lang.Object,java.lang.Object) -> a
com.badlogic.gdx.utils.reflect.ReflectionException -> com.badlogic.gdx.utils.b.e:
com.badlogic.gdx.utils.viewport.FitViewport -> com.badlogic.gdx.utils.c.a:
com.badlogic.gdx.utils.viewport.ScalingViewport -> com.badlogic.gdx.utils.c.b:
    com.badlogic.gdx.utils.Scaling scaling -> a
    void update(int,int,boolean) -> a
com.badlogic.gdx.utils.viewport.Viewport -> com.badlogic.gdx.utils.c.c:
    com.badlogic.gdx.graphics.Camera camera -> a
    float worldWidth -> b
    float worldHeight -> c
    int screenX -> d
    int screenY -> e
    int screenWidth -> f
    int screenHeight -> g
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply(boolean) -> a
    void update(int,int) -> a
    void update(int,int,boolean) -> a
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> a
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    com.badlogic.gdx.graphics.Camera getCamera() -> a
    void setCamera(com.badlogic.gdx.graphics.Camera) -> a
    float getWorldWidth() -> b
    float getWorldHeight() -> c
    void setWorldSize(float,float) -> a
    int getScreenX() -> d
    int getScreenY() -> e
    int getScreenWidth() -> f
    int getScreenHeight() -> g
    void setScreenBounds(int,int,int,int) -> a
com.mygdx.hiddenmarble.android.AndroidLauncher -> com.mygdx.hiddenmarble.android.AndroidLauncher:
    void onCreate(android.os.Bundle) -> onCreate
com.mygdx.hiddenmarble.entities.AbstractDynamicEntity -> com.mygdx.hiddenmarble.a.a:
    com.badlogic.gdx.math.Vector2 getLinearVelocity() -> a
com.mygdx.hiddenmarble.entities.AbstractEntity -> com.mygdx.hiddenmarble.a.b:
    com.badlogic.gdx.physics.box2d.Body body -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    com.badlogic.gdx.physics.box2d.Transform getTransform() -> c
    com.badlogic.gdx.physics.box2d.Body getBody() -> d
com.mygdx.hiddenmarble.entities.Borders -> com.mygdx.hiddenmarble.a.c:
com.mygdx.hiddenmarble.entities.DefaultBorders -> com.mygdx.hiddenmarble.a.d:
    float width -> a
    float height -> b
    float getWidth() -> e_
    float getHeight() -> e
com.mygdx.hiddenmarble.entities.DefaultMarble -> com.mygdx.hiddenmarble.a.e:
    float width -> a
    float getWidth() -> e_
    float getHeight() -> e
com.mygdx.hiddenmarble.entities.DefaultMazeBox -> com.mygdx.hiddenmarble.a.f:
    java.util.List data -> a
    float width -> b
    float height -> c
    float getWidth() -> e_
    float getHeight() -> e
    com.badlogic.gdx.math.Vector2 getTileLocation(maze.Position) -> a
    java.util.List getMazeFixtureDefs() -> f
    java.util.List initData() -> g
com.mygdx.hiddenmarble.entities.DynamicEntity -> com.mygdx.hiddenmarble.a.g:
    com.badlogic.gdx.math.Vector2 getLinearVelocity() -> a
com.mygdx.hiddenmarble.entities.Entity -> com.mygdx.hiddenmarble.a.h:
    float getWidth() -> e_
    float getHeight() -> e
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    com.badlogic.gdx.physics.box2d.Transform getTransform() -> c
com.mygdx.hiddenmarble.entities.Marble -> com.mygdx.hiddenmarble.a.i:
com.mygdx.hiddenmarble.entities.Material -> com.mygdx.hiddenmarble.a.j:
    com.mygdx.hiddenmarble.entities.Material GLASS -> a
    com.mygdx.hiddenmarble.entities.Material METAL -> b
    com.mygdx.hiddenmarble.entities.Material WOOD -> c
    java.util.Map table -> d
    com.mygdx.hiddenmarble.entities.Material[] ENUM$VALUES -> e
    com.mygdx.hiddenmarble.entities.Material getType(com.mygdx.hiddenmarble.entities.Entity) -> a
    com.mygdx.hiddenmarble.entities.Material[] values() -> values
    com.mygdx.hiddenmarble.entities.Material valueOf(java.lang.String) -> valueOf
com.mygdx.hiddenmarble.entities.MazeBox -> com.mygdx.hiddenmarble.a.k:
    com.badlogic.gdx.math.Vector2 getTileLocation(maze.Position) -> a
    java.util.List getMazeFixtureDefs() -> f
com.mygdx.hiddenmarble.entities.MazeFixtureDef -> com.mygdx.hiddenmarble.a.l:
    com.badlogic.gdx.math.Vector2 center -> a
    boolean isCorner -> b
    boolean isSensor -> c
com.mygdx.hiddenmarble.ui.GameScreen -> com.mygdx.hiddenmarble.b.a:
    com.mygdx.hiddenmarble.ui.HiddenMarble game -> a
    com.mygdx.hiddenmarble.utils.SaveState save -> b
    com.badlogic.gdx.graphics.Camera camera -> c
    com.badlogic.gdx.utils.viewport.Viewport viewport -> d
    com.badlogic.gdx.scenes.scene2d.Stage stage -> e
    com.badlogic.gdx.ai.fsm.StateMachine stateMachine -> f
    com.mygdx.hiddenmarble.world.GameWorldListener worldListener -> g
    com.badlogic.gdx.math.Vector2 gravity -> h
    float scaledWidth -> i
    float scaledHeight -> j
    com.mygdx.hiddenmarble.world.GameWorld world -> k
    com.mygdx.hiddenmarble.ui.WorldRenderer renderer -> l
    int[] $SWITCH_TABLE$com$mygdx$hiddenmarble$ui$GameScreen$UIState -> m
    void render(float) -> a
    void resize(int,int) -> a
    void pause() -> c
    void dispose() -> e
    void startNewGame() -> g
    void save(com.mygdx.hiddenmarble.utils.SaveState) -> a
    boolean load(com.mygdx.hiddenmarble.utils.SaveState) -> b
    void revealMaze(float) -> b
    void showNextButton() -> h
    void showGiveUpButton() -> i
    void showGiveUpConfirmation() -> j
    void showWinMessage() -> k
    void showStartIndicator() -> l
    void playWinSound() -> m
    void clearUI() -> n
    void access$0(com.mygdx.hiddenmarble.ui.GameScreen) -> a
    void access$1(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    void access$2(com.mygdx.hiddenmarble.ui.GameScreen,float) -> a
    void access$3(com.mygdx.hiddenmarble.ui.GameScreen) -> c
    void access$4(com.mygdx.hiddenmarble.ui.GameScreen) -> d
    void access$5(com.mygdx.hiddenmarble.ui.GameScreen) -> e
    void access$6(com.mygdx.hiddenmarble.ui.GameScreen) -> f
    void access$7(com.mygdx.hiddenmarble.ui.GameScreen) -> g
    void access$8(com.mygdx.hiddenmarble.ui.GameScreen) -> h
    com.badlogic.gdx.ai.fsm.StateMachine access$9(com.mygdx.hiddenmarble.ui.GameScreen) -> i
    int[] $SWITCH_TABLE$com$mygdx$hiddenmarble$ui$GameScreen$UIState() -> f
com.mygdx.hiddenmarble.ui.GameScreen$1 -> com.mygdx.hiddenmarble.b.b:
    com.mygdx.hiddenmarble.ui.GameScreen this$0 -> a
    void mazeSolved() -> a
com.mygdx.hiddenmarble.ui.GameScreen$ButtonListener -> com.mygdx.hiddenmarble.b.c:
    void clicked(com.mygdx.hiddenmarble.ui.GameScreen) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIButton -> com.mygdx.hiddenmarble.b.d:
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton NEXT -> a
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton GIVE_UP -> b
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton YES -> c
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton NO -> d
    java.lang.String text -> e
    float width -> f
    float height -> g
    float x -> h
    float y -> i
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton[] ENUM$VALUES -> j
    com.badlogic.gdx.scenes.scene2d.ui.Button get(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton[] values() -> values
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton valueOf(java.lang.String) -> valueOf
com.mygdx.hiddenmarble.ui.GameScreen$UIButton$1 -> com.mygdx.hiddenmarble.b.e:
    void clicked(com.mygdx.hiddenmarble.ui.GameScreen) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIButton$2 -> com.mygdx.hiddenmarble.b.f:
    void clicked(com.mygdx.hiddenmarble.ui.GameScreen) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIButton$3 -> com.mygdx.hiddenmarble.b.g:
    void clicked(com.mygdx.hiddenmarble.ui.GameScreen) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIButton$4 -> com.mygdx.hiddenmarble.b.h:
    void clicked(com.mygdx.hiddenmarble.ui.GameScreen) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIButton$5 -> com.mygdx.hiddenmarble.b.i:
    com.mygdx.hiddenmarble.ui.GameScreen$UIButton this$1 -> a
    com.mygdx.hiddenmarble.ui.GameScreen val$screen -> c
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> b
com.mygdx.hiddenmarble.ui.GameScreen$UIState -> com.mygdx.hiddenmarble.b.j:
    com.mygdx.hiddenmarble.ui.GameScreen$UIState PLAY -> a
    com.mygdx.hiddenmarble.ui.GameScreen$UIState CONFIRM_GIVE_UP -> b
    com.mygdx.hiddenmarble.ui.GameScreen$UIState WIN -> c
    com.mygdx.hiddenmarble.ui.GameScreen$UIState GAVE_UP -> d
    com.mygdx.hiddenmarble.ui.GameScreen$UIState[] ENUM$VALUES -> e
    void exit(com.mygdx.hiddenmarble.ui.GameScreen) -> a
    com.mygdx.hiddenmarble.ui.GameScreen$UIState[] values() -> values
    com.mygdx.hiddenmarble.ui.GameScreen$UIState valueOf(java.lang.String) -> valueOf
    void exit(java.lang.Object) -> b
com.mygdx.hiddenmarble.ui.GameScreen$UIState$1 -> com.mygdx.hiddenmarble.b.k:
    void enter(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    void enter(java.lang.Object) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIState$2 -> com.mygdx.hiddenmarble.b.l:
    void enter(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    void enter(java.lang.Object) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIState$3 -> com.mygdx.hiddenmarble.b.m:
    void enter(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    void enter(java.lang.Object) -> a
com.mygdx.hiddenmarble.ui.GameScreen$UIState$4 -> com.mygdx.hiddenmarble.b.n:
    void enter(com.mygdx.hiddenmarble.ui.GameScreen) -> b
    void enter(java.lang.Object) -> a
com.mygdx.hiddenmarble.ui.HiddenMarble -> com.mygdx.hiddenmarble.b.o:
    com.badlogic.gdx.graphics.g2d.Batch batch -> a
    void create() -> a
    void dispose() -> e
com.mygdx.hiddenmarble.ui.WorldRenderer -> com.mygdx.hiddenmarble.b.p:
    com.mygdx.hiddenmarble.world.GameWorld world -> a
    com.badlogic.gdx.graphics.g2d.Sprite marble -> b
    com.badlogic.gdx.graphics.g2d.Sprite wall -> c
    com.badlogic.gdx.graphics.g2d.Sprite background -> d
    com.badlogic.gdx.graphics.g2d.Sprite corners -> e
    com.badlogic.gdx.graphics.g2d.Sprite back -> f
    com.badlogic.gdx.graphics.g2d.Sprite cover -> g
    com.badlogic.gdx.graphics.g2d.Sprite exitGuide -> h
    java.util.List wallPositions -> i
    boolean revealed -> j
    boolean drawInnerBox -> k
    boolean drawCover -> l
    float fadeTimer -> m
    float fadeDuration -> n
    int[] $SWITCH_TABLE$com$mygdx$hiddenmarble$entities$Material -> o
    void render(float,com.badlogic.gdx.graphics.g2d.Batch) -> a
    boolean setRevealed(boolean,float) -> a
    void marbleHit(float,com.mygdx.hiddenmarble.entities.Material) -> a
    void marbleRoll(float,com.mygdx.hiddenmarble.entities.Material) -> b
    void marbleStop() -> b
    void mazeSolved() -> a
    void setCoverAlpha(float) -> a
    void renderCover(com.badlogic.gdx.graphics.g2d.Batch) -> a
    void renderMarble(com.badlogic.gdx.graphics.g2d.Batch) -> b
    void renderMazeBox(com.badlogic.gdx.graphics.g2d.Batch) -> c
    java.util.List getWallPositions() -> d
    int[] $SWITCH_TABLE$com$mygdx$hiddenmarble$entities$Material() -> c
com.mygdx.hiddenmarble.utils.Assets -> com.mygdx.hiddenmarble.c.a:
    com.badlogic.gdx.graphics.Texture bg -> a
    com.badlogic.gdx.graphics.Texture cover -> b
    com.badlogic.gdx.graphics.Texture marble -> c
    com.badlogic.gdx.graphics.Texture wall -> d
    com.badlogic.gdx.graphics.Texture back -> e
    com.badlogic.gdx.graphics.Texture corners -> f
    com.badlogic.gdx.graphics.Texture exit -> g
    com.badlogic.gdx.audio.Music rollWood -> h
    com.badlogic.gdx.audio.Music rollGlass -> i
    com.badlogic.gdx.audio.Sound hitWood -> j
    com.badlogic.gdx.audio.Sound hitGlass -> k
    com.badlogic.gdx.audio.Sound magic -> l
    com.badlogic.gdx.scenes.scene2d.ui.Skin uiSkin -> m
    com.badlogic.gdx.assets.AssetManager manager -> n
    void init() -> a
    void dispose() -> b
    void stopSound() -> c
    void load() -> d
    void initAssets() -> e
com.mygdx.hiddenmarble.utils.BodyHelper -> com.mygdx.hiddenmarble.c.b:
    com.badlogic.gdx.physics.box2d.Body getBordersBody(com.badlogic.gdx.physics.box2d.World,float,float) -> a
    com.badlogic.gdx.physics.box2d.Body getMarbleBody(com.badlogic.gdx.physics.box2d.World,com.badlogic.gdx.math.Vector2,float) -> a
    com.badlogic.gdx.physics.box2d.Body getMazeBoxBody(com.badlogic.gdx.physics.box2d.World,com.mygdx.hiddenmarble.utils.MazeHelper$MazeDef) -> a
    com.badlogic.gdx.physics.box2d.PolygonShape createCorner(maze.Position,com.badlogic.gdx.math.Vector2,float,int,int) -> a
com.mygdx.hiddenmarble.utils.MazeHelper -> com.mygdx.hiddenmarble.c.c:
    com.mygdx.hiddenmarble.utils.MazeHelper$MazeDef getMediumMaze() -> a
    com.mygdx.hiddenmarble.utils.MazeHelper$MazeDef getMaze(int,int) -> a
    maze.Position getTileAt(maze.Position) -> a
com.mygdx.hiddenmarble.utils.MazeHelper$MazeDef -> com.mygdx.hiddenmarble.c.d:
    maze.TileMaze maze -> a
    maze.Position start -> b
    maze.Position exit -> c
com.mygdx.hiddenmarble.utils.SaveState -> com.mygdx.hiddenmarble.c.e:
    com.badlogic.gdx.Preferences preferences -> a
    com.mygdx.hiddenmarble.utils.SaveState$Data data -> b
    boolean load() -> a
    void save() -> b
    void clear() -> c
    void erase() -> d
    com.mygdx.hiddenmarble.world.GameWorld getWorld() -> e
    void setWorld(com.mygdx.hiddenmarble.world.GameWorld) -> a
    java.lang.String getUIState() -> f
    void setUIState(java.lang.String) -> a
com.mygdx.hiddenmarble.utils.SaveState$Data -> com.mygdx.hiddenmarble.c.f:
    com.mygdx.hiddenmarble.world.GameWorld world -> a
    java.lang.String uiState -> b
com.mygdx.hiddenmarble.utils.Serialization -> com.mygdx.hiddenmarble.c.g:
    java.lang.Object fromString(java.lang.String) -> a
    java.lang.String toString(java.lang.Object) -> a
com.mygdx.hiddenmarble.utils.SpriteHelper -> com.mygdx.hiddenmarble.c.h:
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(com.badlogic.gdx.graphics.Texture,float,float) -> a
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(com.badlogic.gdx.graphics.Texture,float,float,float,float) -> a
com.mygdx.hiddenmarble.world.GameWorld -> com.mygdx.hiddenmarble.d.a:
    com.badlogic.gdx.math.Vector2 marblePos -> a
    com.mygdx.hiddenmarble.utils.MazeHelper$MazeDef mazeDef -> b
    float width -> c
    float height -> d
    boolean inMaze -> e
    boolean rolling -> f
    boolean solved -> g
    com.badlogic.gdx.physics.box2d.ContactListener contactListener -> h
    java.util.List eventListeners -> i
    com.badlogic.gdx.physics.box2d.World world -> j
    com.mygdx.hiddenmarble.entities.Marble marble -> k
    com.mygdx.hiddenmarble.entities.MazeBox mazeBox -> l
    float accumulator -> m
    void resize(float,float) -> a
    void addListener(com.mygdx.hiddenmarble.world.GameWorldListener) -> a
    void update(float,com.badlogic.gdx.math.Vector2) -> a
    float getWidth() -> a
    float getHeight() -> b
    com.badlogic.gdx.math.Vector2 getMarbleStart() -> d
    com.badlogic.gdx.math.Vector2 getMazeExit() -> e
    com.badlogic.gdx.math.Vector2 getMarblePosition() -> f
    float getMarbleWidth() -> g
    float getMazeBoxWidth() -> h
    float getMazeBoxHeight() -> i
    com.badlogic.gdx.physics.box2d.Transform getMazeTransform() -> j
    java.util.List getMazeFixtureDefs() -> k
    void dispose() -> c
    boolean checkSensor(com.badlogic.gdx.physics.box2d.Contact) -> a
    void step(float) -> a
    void init(float,float) -> b
    boolean access$0(com.mygdx.hiddenmarble.world.GameWorld,com.badlogic.gdx.physics.box2d.Contact) -> a
    void access$1(com.mygdx.hiddenmarble.world.GameWorld,boolean) -> a
    boolean access$2(com.mygdx.hiddenmarble.world.GameWorld) -> a
    void access$3(com.mygdx.hiddenmarble.world.GameWorld,boolean) -> b
    java.util.List access$4(com.mygdx.hiddenmarble.world.GameWorld) -> b
com.mygdx.hiddenmarble.world.GameWorld$GameWorldContactListener -> com.mygdx.hiddenmarble.d.b:
    com.mygdx.hiddenmarble.world.GameWorld this$0 -> a
    void beginContact(com.badlogic.gdx.physics.box2d.Contact) -> a
    void endContact(com.badlogic.gdx.physics.box2d.Contact) -> b
    void preSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.Manifold) -> a
    void postSolve(com.badlogic.gdx.physics.box2d.Contact,com.badlogic.gdx.physics.box2d.ContactImpulse) -> a
com.mygdx.hiddenmarble.world.GameWorldAdapter -> com.mygdx.hiddenmarble.d.c:
    void marbleHit(float,com.mygdx.hiddenmarble.entities.Material) -> a
    void marbleRoll(float,com.mygdx.hiddenmarble.entities.Material) -> b
    void marbleStop() -> b
    void mazeSolved() -> a
com.mygdx.hiddenmarble.world.GameWorldListener -> com.mygdx.hiddenmarble.d.d:
    void marbleHit(float,com.mygdx.hiddenmarble.entities.Material) -> a
    void marbleRoll(float,com.mygdx.hiddenmarble.entities.Material) -> b
    void marbleStop() -> b
    void mazeSolved() -> a
maze.ImmutablePosition -> a.a:
    int x -> a
    int y -> b
    int getX() -> a
    int getY() -> b
maze.Maze -> a.b:
    int width -> b
    int height -> c
    byte[] maze -> d
    boolean $assertionsDisabled -> a
    void generate() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isWall(int,int,maze.Maze$Direction) -> a
    java.lang.String toString() -> toString
    void resetFill() -> d
    void carve(int,int,maze.Maze$Direction) -> b
    void carve(maze.Position,maze.Maze$Direction) -> a
    boolean isClosed(int,int) -> a
    boolean isBorder(int,int,maze.Maze$Direction) -> c
    boolean isInBounds(int,int) -> b
    void checkPosition(int,int) -> c
    int getFlags(int,int) -> d
    int getFlags(maze.Position) -> a
    void setFlags(int,int,int) -> a
    void setFlags(maze.Position,int) -> a
maze.Maze$Direction -> a.c:
    maze.Maze$Direction UP -> a
    maze.Maze$Direction LEFT -> b
    maze.Maze$Direction DOWN -> c
    maze.Maze$Direction RIGHT -> d
    int dx -> e
    int dy -> f
    int mask -> g
    maze.Maze$Direction reverse -> h
    maze.Maze$Direction[] ENUM$VALUES -> i
    maze.Maze$Direction getReverse() -> a
    maze.Maze$Direction[] values() -> values
    maze.Maze$Direction valueOf(java.lang.String) -> valueOf
    int access$2(maze.Maze$Direction) -> a
maze.Node -> a.d:
    int x -> a
    int y -> b
    void translate(int,int) -> a
    int getX() -> a
    int getY() -> b
maze.Position -> a.e:
    int getX() -> a
    int getY() -> b
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
maze.PositionOutOfBoundsException -> a.f:
maze.RecursiveBacktracker -> a.g:
    org.apache.commons.math3.random.RandomGenerator rnd -> b
    maze.Node start -> c
    void generate() -> a
    void recursiveBacktrack(maze.Node) -> a
    int getMoves(maze.Node,maze.Maze$Direction[]) -> a
maze.TileMaze -> a.h:
    maze.Maze maze -> a
    int width -> b
    int height -> c
    void setMaze(maze.Maze) -> a
    int getWidth() -> a
    int getHeight() -> b
    boolean isWall(int,int) -> a
    java.lang.String toString() -> toString
    void checkBounds(int,int) -> b
maze.Xorshift32 -> a.i:
    int seed -> a
    void setSeed(int) -> a
    void setSeed(long) -> a
    int next(int) -> b
    int nextInt(int) -> c
org.apache.commons.math3.exception.MathIllegalArgumentException -> b.a.a.a.a.a:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalNumberException -> b.a.a.a.a.b:
    java.lang.Integer INTEGER_ZERO -> a
    java.lang.Number argument -> b
org.apache.commons.math3.exception.NotStrictlyPositiveException -> b.a.a.a.a.c:
org.apache.commons.math3.exception.NumberIsTooSmallException -> b.a.a.a.a.d:
    java.lang.Number min -> b
    boolean boundIsAllowed -> c
org.apache.commons.math3.exception.util.ArgUtils -> b.a.a.a.a.a.a:
    java.lang.Object[] flatten(java.lang.Object[]) -> a
org.apache.commons.math3.exception.util.ExceptionContext -> b.a.a.a.a.a.b:
    java.lang.Throwable throwable -> a
    java.util.List msgPatterns -> b
    java.util.List msgArguments -> c
    java.util.Map context -> d
    void addMessage(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.String getMessage() -> a
    java.lang.String getLocalizedMessage() -> b
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String buildMessage(java.util.Locale,java.lang.String) -> a
org.apache.commons.math3.exception.util.Localizable -> b.a.a.a.a.a.c:
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.exception.util.LocalizedFormats -> b.a.a.a.a.a.d:
    org.apache.commons.math3.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> a
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZE_EXCEEDS_MAX_VARIABLES -> b
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> c
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> d
    org.apache.commons.math3.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> e
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> f
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> g
    org.apache.commons.math3.exception.util.LocalizedFormats BANDWIDTH -> h
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> i
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> j
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> k
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> l
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> m
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> n
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> o
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> p
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> q
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> r
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> s
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> t
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> u
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> v
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> w
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> x
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> y
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> z
    org.apache.commons.math3.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> A
    org.apache.commons.math3.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> B
    org.apache.commons.math3.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> C
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> D
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX -> E
    org.apache.commons.math3.exception.util.LocalizedFormats CONSTRAINT -> F
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> G
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> H
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> I
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> J
    org.apache.commons.math3.exception.util.LocalizedFormats CONVERGENCE_FAILED -> K
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSING_BOUNDARY_LOOPS -> L
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSOVER_RATE -> M
    org.apache.commons.math3.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> N
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> O
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ORIG_AND_PERMUTED_DATA -> P
    org.apache.commons.math3.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> Q
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> R
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> S
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH -> T
    org.apache.commons.math3.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> U
    org.apache.commons.math3.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> V
    org.apache.commons.math3.exception.util.LocalizedFormats DUPLICATED_ABSCISSA_DIVISION_BY_ZERO -> W
    org.apache.commons.math3.exception.util.LocalizedFormats ELITISM_RATE -> X
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> Y
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_INTERPOLATION_SAMPLE -> Z
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> aa
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> ab
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> ac
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> ad
    org.apache.commons.math3.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> ae
    org.apache.commons.math3.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> af
    org.apache.commons.math3.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> ag
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATION -> ah
    org.apache.commons.math3.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> ai
    org.apache.commons.math3.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> aj
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_BRACKETING -> ak
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> al
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> am
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> an
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> ao
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> ap
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> aq
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> ar
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> as
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> at
    org.apache.commons.math3.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> au
    org.apache.commons.math3.exception.util.LocalizedFormats ILL_CONDITIONED_OPERATOR -> av
    org.apache.commons.math3.exception.util.LocalizedFormats INCONSISTENT_STATE_AT_2_PI_WRAPPING -> aw
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> ax
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> ay
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> az
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX -> aA
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_FINITE_NUMBER -> aB
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_BOUND -> aC
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ELEMENT -> aD
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> aE
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> aF
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> aG
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> aH
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> aI
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> aJ
    org.apache.commons.math3.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> aK
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA -> aL
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> aM
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> aN
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSION -> aO
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> aP
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> aQ
    org.apache.commons.math3.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS -> aR
    org.apache.commons.math3.exception.util.LocalizedFormats INTERNAL_ERROR -> aS
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_DIGIT -> aT
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_CHROMOSOME -> aU
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> aV
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_FIXED_LENGTH_CHROMOSOME -> aW
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> aX
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> aY
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> aZ
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_REGRESSION -> ba
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> bb
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_OBSERVATION -> bc
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> bd
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> be
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATIONS -> bf
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> bg
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> bh
    org.apache.commons.math3.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> bi
    org.apache.commons.math3.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> bj
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> bk
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> bl
    org.apache.commons.math3.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> bm
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATIONS -> bn
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_COUNT_EXCEEDED -> bo
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> bp
    org.apache.commons.math3.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> bq
    org.apache.commons.math3.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> br
    org.apache.commons.math3.exception.util.LocalizedFormats MUTATION_RATE -> bs
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> bt
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> bu
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> bv
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> bw
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> bx
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> by
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> bz
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESSES -> bA
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> bB
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_INTERPOLATION_POINTS -> bC
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_TRIALS -> bD
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_CONVEX -> bE
    org.apache.commons.math3.exception.util.LocalizedFormats ROBUSTNESS_ITERATIONS -> bF
    org.apache.commons.math3.exception.util.LocalizedFormats START_POSITION -> bG
    org.apache.commons.math3.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> bH
    org.apache.commons.math3.exception.util.LocalizedFormats NON_INVERTIBLE_TRANSFORM -> bI
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> bJ
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> bK
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> bL
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> bM
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> bN
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> bO
    org.apache.commons.math3.exception.util.LocalizedFormats NORM -> bP
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_INFINITE -> bQ
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_NAN -> bR
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> bS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> bT
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> bU
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> bV
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> bW
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> bX
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> bY
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> bZ
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> ca
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_MATRIX -> cb
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_OPERATOR -> cc
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SELF_ADJOINT_OPERATOR -> cd
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_OPERATOR -> ce
    org.apache.commons.math3.exception.util.LocalizedFormats DEGREES_OF_FREEDOM -> cf
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> cg
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> ch
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> ci
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE -> cj
    org.apache.commons.math3.exception.util.LocalizedFormats BASE -> ck
    org.apache.commons.math3.exception.util.LocalizedFormats EXPONENT -> cl
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> cm
    org.apache.commons.math3.exception.util.LocalizedFormats LENGTH -> cn
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> co
    org.apache.commons.math3.exception.util.LocalizedFormats MEAN -> cp
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> cq
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> cr
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> cs
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_SIZE -> ct
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> cu
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> cv
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_SIZE -> cw
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> cx
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> cy
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> cz
    org.apache.commons.math3.exception.util.LocalizedFormats SCALE -> cA
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> cB
    org.apache.commons.math3.exception.util.LocalizedFormats SHAPE -> cC
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> cD
    org.apache.commons.math3.exception.util.LocalizedFormats STANDARD_DEVIATION -> cE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> cF
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> cG
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> cH
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> cI
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> cJ
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> cK
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> cL
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> cM
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> cN
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> cO
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> cP
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUPPORTED_IN_DIMENSION_N -> cQ
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> cR
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SYMMETRIC_MATRIX -> cS
    org.apache.commons.math3.exception.util.LocalizedFormats NO_BIN_SELECTED -> cT
    org.apache.commons.math3.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> cU
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DATA -> cV
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> cW
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> cX
    org.apache.commons.math3.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> cY
    org.apache.commons.math3.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> cZ
    org.apache.commons.math3.exception.util.LocalizedFormats NO_REGRESSORS -> da
    org.apache.commons.math3.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> db
    org.apache.commons.math3.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> dc
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_NOT_ALLOWED -> dd
    org.apache.commons.math3.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> de
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED -> df
    org.apache.commons.math3.exception.util.LocalizedFormats COVARIANCE_MATRIX -> dg
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR -> dh
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> di
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION -> dj
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION -> dk
    org.apache.commons.math3.exception.util.LocalizedFormats IMAGINARY_FORMAT -> dl
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_ARRAY -> dm
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR -> dn
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_FORMAT -> do
    org.apache.commons.math3.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> dp
    org.apache.commons.math3.exception.util.LocalizedFormats REAL_FORMAT -> dq
    org.apache.commons.math3.exception.util.LocalizedFormats WHOLE_FORMAT -> dr
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> ds
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> dt
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> du
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> dv
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> dw
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> dx
    org.apache.commons.math3.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> dy
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> dz
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> dA
    org.apache.commons.math3.exception.util.LocalizedFormats BOBYQA_BOUND_DIFFERENCE_CONDITION -> dB
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> dC
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_CONFIDENCE_LEVEL -> dD
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> dE
    org.apache.commons.math3.exception.util.LocalizedFormats SIGNIFICANCE_LEVEL -> dF
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> dG
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> dH
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE -> dI
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> dJ
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_LEFT -> dK
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_RIGHT -> dL
    org.apache.commons.math3.exception.util.LocalizedFormats OUTLINE_BOUNDARY_LOOP_OPEN -> dM
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW -> dN
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> dO
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> dP
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> dQ
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> dR
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> dS
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> dT
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL -> dU
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> dV
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> dW
    org.apache.commons.math3.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> dX
    org.apache.commons.math3.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> dY
    org.apache.commons.math3.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> dZ
    org.apache.commons.math3.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> ea
    org.apache.commons.math3.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> eb
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> ec
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX -> ed
    org.apache.commons.math3.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> ee
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> ef
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> eg
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> eh
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLE_MESSAGE -> ei
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_MATRIX -> ej
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_OPERATOR -> ek
    org.apache.commons.math3.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> el
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> em
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_TOURNAMENT_ARITY -> en
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> eo
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_REGRESSORS -> ep
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> eq
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> er
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> es
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> et
    org.apache.commons.math3.exception.util.LocalizedFormats TRUST_REGION_STEP_FAILED -> eu
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> ev
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> ew
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> ex
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> ey
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> ez
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> eA
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> eB
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> eC
    org.apache.commons.math3.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> eD
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_MODE -> eE
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_PARAMETER -> eF
    org.apache.commons.math3.exception.util.LocalizedFormats UNMATCHED_ODE_IN_EXPANDED_SET -> eG
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE_AS_TYPE -> eH
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE -> eI
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> eJ
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> eK
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> eL
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> eM
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> eN
    org.apache.commons.math3.exception.util.LocalizedFormats ARITHMETIC_EXCEPTION -> eO
    org.apache.commons.math3.exception.util.LocalizedFormats ILLEGAL_STATE -> eP
    org.apache.commons.math3.exception.util.LocalizedFormats USER_EXCEPTION -> eQ
    org.apache.commons.math3.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> eR
    org.apache.commons.math3.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> eS
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> eT
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> eU
    org.apache.commons.math3.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> eV
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> eW
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> eX
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_POINTS -> eY
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR -> eZ
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> fa
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> fb
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM -> fc
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> fd
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> fe
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> ff
    java.lang.String sourceFormat -> fg
    org.apache.commons.math3.exception.util.LocalizedFormats[] $VALUES -> fh
    org.apache.commons.math3.exception.util.LocalizedFormats[] values() -> values
    org.apache.commons.math3.exception.util.LocalizedFormats valueOf(java.lang.String) -> valueOf
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.random.BitsStreamGenerator -> b.a.a.a.b.a:
    double nextGaussian -> a
    int next(int) -> b
    int nextInt(int) -> c
    void clear() -> a
org.apache.commons.math3.random.RandomGenerator -> b.a.a.a.b.b:
    int nextInt(int) -> c
